# TCP和UDP

##介绍TCP UDP

TCP和UDP在传输层

传输控制协议TCP：(有流量控制，拥塞控制，提供全双工通信,连接只能是点对点的)

* 面向连接的、可靠的、基于字节流 的传输层通信协议
* 将应用层的数据流分割成报文段并发送给目标节点的TCP层
* 数据包都有序号，对方收到则发送ACK确认，未收到则重传
* 使用校验和来检验数据在传输过程中是否有误

用户数据报协议UDP：

* 面向非连接
* 不维护连接状态，支持同时向多个客户端传输相同的消息
* 数据包报头只有8个字节（4个字段），额外开销较小
* 吞吐量只受限于数据生成速率、传输速率以及机器性能
* 尽最大努力交付，不保证可靠交付，不需要维护复杂的链接状态表
* 面向报文，不对应用程序提交的报文信息进行拆分或者合并（保留边界，交给上层解决）

## TCP UDP 协议的区别

![TCP、UDP协议的区别](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg)

# TCP 三次握手

- ![image-20210318112847127](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210318112847127.png)

- 详细过程：如果一切正常的话

  第一次握手 客—>服：客户端发送SYN报文（不带数据）（seq=x）到服务器，发送后进入SYN-Sent状态；

  第二次握手 服—>客：服务器发送一个SYN+ACK报文给客户端，里面指定（seq:y && ack=x+1），发送后服务端进入SYN-RCVD状态。（不带数据）客户端收到服务器的SYN+ACK包，客户端接收后进入ESTABLISHED

  第三次握手 客—>服：向服务器发送确认ACK报文（seq=x+1，ack=y+1），此包发送完毕，服务器接收后也ESTABLISHED状态，会进入完成三次握手。（可以携带数据）

## **为什么要三次握手**

1. 三次握手刚刚好可以保证双方确认自己与对方的发送与接收是正常的。三次握手是一个最少的次数。

2. 第三次握手能保证服务端资源不会由于网络问题导致的浪费，为什么这么说？如果tcp只有两次握手的话，如果第一次客户端发起的SYN连接请求由于网络原因，还没到达服务端，这时候客户端触发超时重传，发了第二个SYN请求，服务端接收到SYN请求，进行第二次握手，建立连接，这时候我们第一次发的SYN请求到达，服务端再进行第二次握手，那么这时候服务端就以为又要建立连接了，但第二次握手客户端是不会理会的，造成服务端资源的浪费。如果是三次握手才建立连接的话，客户端没返回ACK的话连接就不建立。

## 第三次握手ACK包丢失怎么办？

服务端第一次收到客户端的SYN之后，就会处于SYN-RCVD状态，此时双方还没有完全建立连接，服务端会将这个连接放进一个半连接队列里面，如果服务端在发送完SYN-ACK包，没有收到客户端的ACK包的话，那么服务端就会进行重传，如果超过重传次数5次（间隔1+2+4+8+16+32=63s）的话，系统就把这个连接从半连接队列里面删除，释放这个半连接。

## SYN攻击

服务端的资源分配是第二次握手的时候分配的，攻击者可以伪造大量不存在的ip地址，然后在第一次握手的时候向服务端不断的发送SYN数据包，服务端就会回复SYN-ACK，然后把这个半连接放进半连接队列里面，服务端需要不断重试直到这些半连接达到重试次数才会把这个半连接移出队列，所以如果有大量的这种半连接占用半连接队列占满的话，正常的连接请求会因为半连接队列已经满了被丢弃。

防范方法：

1. 增大半连接队列的大小
2. 减少服务端重试次数
3. SYN Cookies，先不分配资源，先回复SYN-ACK，等到客户端回复之后再分配资源建立连接

# TCP 四次挥手

TCP四次挥手

![img](D:\Acan\canwork\Note-master\网络.assets\v2-6e5f05603526c1d259b300f20b8857a5_720w.jpg)

1. 客户端->服务端（FIN=1 && seq=u）客户端由ESTABLISHED转化为FIN-WAIT-1  ps：u为此前客户端发送的最后一个字节的序号+1
2. 服务端->客户端（ACK=1 && seq=v && 确认号:u+1）服务端由ESTABLISHED转化为CLOSE-WAIT，客户端接收到之后由FIN-WAIT-1转化为FIN-WAIT-2，这时候服务端还能继续发送数据，客户端还能继续接收数据  ps：v为此前服务端发送的最后一个字节的序号+1
3. 服务端->客户端（FIN=1 && ACK=1 && seq=v+n && 确认号:u+1）服务端由CLOSE-WAIT转化为LAST-ACK，客户端接收之后由FIN-WAIT-2转化为TIME-WAIT  ps：v+n，如果半关闭状态没有发送数据的话，n为0
4. 客户端->服务端（ACK=1 && seq=u+1 &&  确认号:v+n+1） 客户端转化为TIME-WAIT阶段等待2MSL后关闭连接，服务端收到之后关闭连接。

## 为什么挥手需要四次？

在关闭连接的时候，客户端发起FIN请求，这时候服务端可能还有数据需要发送，所以先回一个ACK，等数据发送完了之后再回一个FIN+ACK，得把回应拆成两步，所以有四次。

## 为什么最后需要等待2MSL?

MSL是最大报文存活时间，超过这个时间的报文都会被丢弃。

1. 保证客户端发送的最后一个ACK能够到达服务端。因为最后一个ACK可能会丢失，服务端会触发超时重传，重传FIN+ACK，客户端在等待的这段时间能够回应服务端，如果客户端没等待就关闭连接了，就会造成无法回复服务端的FIN+ACK，会导致服务端没办法正常关闭。
2. 客户端需要保证在本次连接中的所有报文都消亡，保证下一个新的连接中不会出现旧连接中的旧报文。

# TCP怎么保证可靠传输？

1. 使用以字节为单位的滑动窗口，TCP将要发送的字节进行一个编号，使用滑动窗口协议对字节进行传输，发送方发送滑动窗口中的字节，接收方对接收的字节进行一个校验和累积确认，发送方接收到确认之后移动窗口，发送接下来的字节。
2. 超时重传，如果发送方收不到发送方的确认，超过一定时间就会触发超时重传机制。为了解决一定得超时才触发重传的弊端就出现了快速重传，就是发送端连续接收到某个序列号的ACK包的话就立刻重传这个序列号和序列号之后的字节。为了让发送方知道接收方接受了哪些字节，不用做没意义的重传，就可以使用选择重传，使用tcp首部的选项来存放这些信息，发送方接收到接收方的ACK的时候就能知道哪些包丢了哪些包没丢，只需要重传哪些字节就行，避免没意义的重传。
3. 流量控制，避免发送方发送的太快，导致接收方来不及接收导致的丢包。在通信的过程中，接收方根据接收缓存中可用缓存的大小动态的调整发送方窗口的上限值，接收方将自己可用的接收缓存的大小写到tcp首部的窗口字段，发送方根据这个字段来调整发送的速率。ps：当接收方传回的窗口值为0，那么发送方将停止发送数据，如果发送方还有数据要发送的话，会周期性的向接收方发送窗口探测，强制接收方回复可接收的窗口大小。

# TCP的滑动窗口

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

TCP会话的双方都各自维护一个“发送窗口”（拥塞窗口）和一个“接收窗口”

1）对于TCP会话的发送方，任何时候在其发送缓存内的数据都可以分为4类：

- “已经发送并得到对端ACK的”，数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。
- “已经发送但还未收到对端ACK的”，已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。
- “未发送但对端允许发送的”
- “未发送且对端不允许发送”

2）对于TCP的接收方，在某一时刻在它的接收缓存内存在3种。“已接收”，“未接收准备接收”，“未接收并未准备接收”（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。其中“未接收准备接收”称之为接收窗口。

> TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。

# TCP拥塞控制

tcp发送方需要维护一个接收窗口还要维护一个拥塞窗口，发送数据的大小取这两个窗口的最小值。

如果出现重传计时器超时或者收到三个重复确认的话，发送方就认为出现了网络拥塞。

4个算法，发送方维护了一个拥塞窗口和一个慢启动门限

1. 慢启动，拥塞窗口先设为1个MSS，然后发送，收到确认之后，拥塞窗口为2，再发送，再收到确认之后，拥塞窗口变为4，呈指数的上升，当超过慢启动门限的时候改为拥塞避免算法。
2. 拥塞避免，发送，收到确认之后，拥塞窗口+1，呈线性增长。当出现网络拥塞的时候，将慢启动门限设为当前拥塞窗口的一半，将拥塞窗口设为1，再慢启动，拥塞避免。
3. 快速重传和快速恢复，当出现拥塞的时候有两种情况，一种是重传计时器超时，一种是收到三个重复确认，这两种情况的拥塞程度是不一样的，收到三个重复确认的情况表明丢失分组以外的另外三个分组已经被接收方接受了，所以和超时不同，网络还是有一定交付能力的，如果使用慢启动的话反应会太过剧烈，影响效率。所以当收到三个重复确认的时候就重新设置慢启动门限然后将拥塞窗口设置为慢启动门限的值然后使用拥塞避免算法。当收到三个重复确认的时候，发送方就知道包丢失了，就会触发快速重传机制。

# Http

请求报文：

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 最后是请求的内容主体

***

# SSL/TLS四次握手

1. 客户端 Client Hello （支持的协议版本，客户端随机数，支持的加密算法）
2. 服务端 Sever Hello （确认加密协议版本，服务端随机数，确认加密算法，服务器证书）
3. 客户端回应（公钥加密随机数，编码改变通知，握手结束通知）
4. 服务端回应（编码改变通知，握手结束通知）

# 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)

百度好像最喜欢问这个问题。

> 打开一个网页，整个过程会使用哪些协议？

图解（图片来源：《图解HTTP》）：

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg" style="zoom:50%;" />

> 上图有一个错误，请注意，是OSPF不是OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议

总体来说分为以下几个过程:

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

具体可以参考下面这篇文章：

- [https://segmentfault.com/a/1190000006879700](https://segmentfault.com/a/1190000006879700)

# HTTP长连接,短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。** 

—— [《HTTP长连接、短连接究竟是什么？》](https://www.cnblogs.com/gotodsp/p/6366163.html)

# Cookie的作用是什么?和Session有什么区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

 **Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

# HTTP 和 HTTPS 的区别？

1. **端口** ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
2. **安全性和资源消耗：** HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。
   - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
   - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。