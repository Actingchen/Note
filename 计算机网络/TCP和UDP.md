# TCP和UDP

##介绍

TCP和UDP在传输层

传输控制协议TCP：

* 面向连接的、可靠的、基于字节流 的传输层通信协议
* 将应用层的数据流分割成报文段并发送给目标节点的TCP层
* 数据包都有序号，对方收到则发送ACK确认，未收到则重传
* 使用校验和来检验数据在传输过程中是否有误

##UDP和TCP的特点

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

##UDP的报文段格式

<img src="..\images\image-20201129145741909.png" alt="image-20201129145741909" style="zoom:150%;" />



首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。**12 字节的伪首部是为了计算检验和临时添加的**。

##TCP报文段格式

![image-20201129145527883](..\images\image-20201129145527883.png)

- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。用来控制速率，即流量控制。

## TCP,UDP 协议的区别

![TCP、UDP协议的区别](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg)

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

# TCP 三次握手

- ![image-20210318112847127](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210318112847127.png)

- 详细过程：如果一切正常的话

  第一次握手 客—>服：客户端发送SYN报文（不带数据）（seq=x）到服务器，发送后进入SYN-Sent状态；

  第二次握手 服—>客：服务器发送一个SYN+ACK报文给客户端，里面指定（seq:y && ack=x+1），发送后服务端进入SYN-RCVD状态。（不带数据）

  第三次握手 客—>服：客户端收到服务器的SYN+ACK包，客户端接收后进入ESTABLISHED，向服务器发送确认ACK报文（seq=x+1，ack=y+1），此包发送完毕，服务器接收后也ESTABLISHED状态，会进入完成三次握手。（可以携带数据）

## **为什么要三次握手**

1. 三次握手刚刚好可以保证双方确认自己与对方的发送与接收是正常的。三次握手是一个最少的次数。

2. 第三次握手能保证服务端资源不会由于网络问题导致的浪费，为什么这么说？如果tcp只有两次握手的话，如果第一次客户端发起的SYN连接请求由于网络原因，还没到达服务端，这时候客户端触发超时重传，发了第二个SYN请求，服务端接收到SYN请求，进行第二次握手，建立连接，这时候我们第一次发的SYN请求到达，服务端再进行第二次握手，那么这时候服务端就以为又要建立连接了，但第二次握手客户端是不会理会的，造成服务端资源的浪费。如果是三次握手才建立连接的话，客户端没返回ACK的话连接就不建立。

## 第三次握手ACK包丢失怎么办？

服务端第一次收到客户端的SYN之后，就会处于SYN-RCVD状态，此时双方还没有完全建立连接，服务端会将这个连接放进一个半连接队列里面，如果服务端在发送完SYN-ACK包，没有收到客户端的ACK包的话，那么服务端就会进行重传，如果超过重传次数5次（间隔1+2+4+8+16+32=63s）的话，系统就把这个连接从半连接队列里面删除，释放这个半连接。

## SYN攻击

服务端的资源分配是第二次握手的时候分配的，攻击者可以伪造大量不存在的ip地址，然后在第一次握手的时候向服务端不断的发送SYN数据包，服务端就会回复SYN-ACK，然后把这个半连接放进半连接队列里面，服务端需要不断重试直到这些半连接达到重试次数才会把这个半连接移出队列，所以如果有大量的这种半连接占用半连接队列占满的话，正常的连接请求会因为半连接队列已经满了被丢弃。

防范方法：

1. 增大半连接队列的大小
2. 减少服务端重试次数
3. SYN Cookies，先不分配资源，先回复SYN-ACK，等到客户端回复之后再分配资源建立连接

# TCP 四次挥手

TCP四次挥手

![img](D:\Acan\canwork\Note-master\网络.assets\v2-6e5f05603526c1d259b300f20b8857a5_720w.jpg)

1. 客户端->服务端（FIN=1 && seq=u）客户端由ESTABLISHED转化为FIN-WAIT-1  ps：u为此前客户端发送的最后一个字节的序号+1
2. 服务端->客户端（ACK=1 && seq=v && 确认号:u+1）服务端由ESTABLISHED转化为CLOSE-WAIT，客户端接收到之后由FIN-WAIT-1转化为FIN-WAIT-2，这时候服务端还能继续发送数据，客户端还能继续接收数据  ps：v为此前服务端发送的最后一个字节的序号+1
3. 服务端->客户端（FIN=1 && ACK=1 && seq=v+n && 确认号:u+1）服务端由CLOSE-WAIT转化为LAST-ACK，客户端接收之后由FIN-WAIT-2转化为TIME-WAIT  ps：v+n，如果半关闭状态没有发送数据的话，n为0
4. 客户端->服务端（ACK=1 && seq=u+1 &&  确认号:v+n+1） 客户端转化为TIME-WAIT阶段等待2MSL后关闭连接，服务端收到之后关闭连接。

## 为什么挥手需要四次？

在关闭连接的时候，客户端发起FIN请求，这时候服务端可能还有数据需要发送，所以先回一个ACK，等数据发送完了之后再回一个FIN+ACK，得把回应拆成两步，所以有四次。

## 为什么最后需要等待2MSL?

MSL是最大报文存活时间，超过这个时间的报文都会被丢弃。

1. 保证客户端发送的最后一个ACK能够到达服务端。因为最后一个ACK可能会丢失，服务端会触发超时重传，重传FIN+ACK，客户端在等待的这段时间能够回应服务端，如果客户端没等待就关闭连接了，就会造成无法回复服务端的FIN+ACK，会导致服务端没办法正常关闭。
2. 客户端需要保证在本次连接中的所有报文都消亡，保证下一个新的连接中不会出现旧连接中的旧报文。

# TCP怎么保证可靠传输？

1. 使用以字节为单位的滑动窗口，TCP将要发送的字节进行一个编号，使用滑动窗口协议对字节进行传输，发送方发送滑动窗口中的字节，接收方对接收的字节进行一个校验和累积确认，发送方接收到确认之后移动窗口，发送接下来的字节。
2. 超时重传，如果发送方收不到发送方的确认，超过一定时间就会触发超时重传机制。为了解决一定得超时才触发重传的弊端就出现了快速重传，就是发送端连续接收到某个序列号的ACK包的话就立刻重传这个序列号和序列号之后的字节。为了让发送方知道接收方接受了哪些字节，不用做没意义的重传，就可以使用选择重传，使用tcp首部的选项来存放这些信息，发送方接收到接收方的ACK的时候就能知道哪些包丢了哪些包没丢，只需要重传哪些字节就行，避免没意义的重传。
3. 流量控制，避免发送方发送的太快，导致接收方来不及接收导致的丢包。在通信的过程中，接收方根据接收缓存中可用缓存的大小动态的调整发送方窗口的上限值，接收方将自己可用的接收缓存的大小写到tcp首部的窗口字段，发送方根据这个字段来调整发送的速率。ps：当接收方传回的窗口值为0，那么发送方将停止发送数据，如果发送方还有数据要发送的话，会周期性的向接收方发送窗口探测，强制接收方回复可接收的窗口大小。

# TCP拥塞控制

tcp发送方需要维护一个接收窗口还要维护一个拥塞窗口，发送数据的大小取这两个窗口的最小值。

如果出现重传计时器超时或者收到三个重复确认的话，发送方就认为出现了网络拥塞。

4个算法，发送方维护了一个拥塞窗口和一个慢启动门限

1. 慢启动，拥塞窗口先设为1个MSS，然后发送，收到确认之后，拥塞窗口为2，再发送，再收到确认之后，拥塞窗口变为4，呈指数的上升，当超过慢启动门限的时候改为拥塞避免算法。
2. 拥塞避免，发送，收到确认之后，拥塞窗口+1，呈线性增长。当出现网络拥塞的时候，将慢启动门限设为当前拥塞窗口的一半，将拥塞窗口设为1，再慢启动，拥塞避免。
3. 快速重传和快速恢复，当出现拥塞的时候有两种情况，一种是重传计时器超时，一种是收到三个重复确认，这两种情况的拥塞程度是不一样的，收到三个重复确认的情况表明丢失分组以外的另外三个分组已经被接收方接受了，所以和超时不同，网络还是有一定交付能力的，如果使用慢启动的话反应会太过剧烈，影响效率。所以当收到三个重复确认的时候就重新设置慢启动门限然后将拥塞窗口设置为慢启动门限的值然后使用拥塞避免算法。当收到三个重复确认的时候，发送方就知道包丢失了，就会触发快速重传机制。

# Http

请求报文：

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 最后是请求的内容主体

***

# SSL/TLS四次握手

1. 客户端 Client Hello （支持的协议版本，客户端随机数，支持的加密算法）
2. 服务端 Sever Hello （确认加密协议版本，服务端随机数，确认加密算法，服务器证书）
3. 客户端回应（公钥加密随机数，编码改变通知，握手结束通知）
4. 服务端回应（编码改变通知，握手结束通知）

