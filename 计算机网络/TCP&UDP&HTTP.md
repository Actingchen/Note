# TCP和UDP

##介绍TCP UDP

TCP和UDP在传输层

传输控制协议TCP：(有流量控制，拥塞控制，提供全双工通信,连接只能是点对点的)

* 面向连接的、可靠的、基于字节流 的传输层通信协议
* 将应用层的数据流分割成报文段并发送给目标节点的TCP层
* 数据包都有序号，对方收到则发送ACK确认，未收到则重传
* 使用校验和来检验数据在传输过程中是否有误

用户数据报协议UDP：

* 面向非连接
* 不维护连接状态，支持同时向多个客户端传输相同的消息
* 数据包报头只有8个字节（4个字段），额外开销较小
* 吞吐量只受限于数据生成速率、传输速率以及机器性能
* 尽最大努力交付，不保证可靠交付，不需要维护复杂的链接状态表
* 面向报文，不对应用程序提交的报文信息进行拆分或者合并（保留边界，交给上层解决）

## TCP UDP 协议的区别

![TCP、UDP协议的区别](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg)

# TCP 三次握手

- ![image-20210318112847127](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210318112847127.png)

- 详细过程：如果一切正常的话

  第一次握手 客—>服：客户端发送SYN包（不带数据）（seq=x）到服务器，发送后客户端进入SYN-Sent状态，等待服务器确认；

  第二次握手 服—>客：服务器收到SYN包，确认客户的SYN包，自己设置ack=对方的seq值+1放进一个SYN+ACK报文发送给客户端（seq:y && ack=x+1），发送后服务端进入SYN-RCVD状态。（不带数据）客户端收到服务器的SYN+ACK包，客户端接收后进入ESTABLISHED

  第三次握手 客—>服：向服务器发送确认ACK报文（seq=x+1，ack=y+1），此包发送完毕，服务器接收后也ESTABLISHED状态，会进入完成三次握手。（可以携带数据）

## **为什么要三次握手**

1. 三次握手刚刚好可以保证双方确认自己和对方的发送与接收是正常的。三次握手是一个最少的次数。

2. 第三次握手能保证服务端资源不会由于网络问题导致的浪费，为什么这么说？如果tcp只有两次握手的话，如果第一次客户端发起的SYN连接请求由于网络原因，还没到达服务端，这时候客户端触发超时重传，发了第二个SYN请求，服务端接收到SYN请求，进行第二次握手，建立连接，这时候我们第一次发的SYN请求到达，服务端再进行第二次握手，那么这时候服务端就以为又要建立连接了，但第二次握手客户端是不会理会的，造成服务端资源的浪费。如果是三次握手才建立连接的话，客户端没返回ACK的话连接就不建立。

## 第三次握手ACK包丢失怎么办？

服务端第一次收到客户端的SYN之后，就会处于SYN-RCVD状态，此时双方还没有完全建立连接，服务端会将这个连接放进一个半连接队列里面，如果服务端在发送完SYN-ACK包，没有收到客户端的ACK包的话，那么服务端就会进行重传，如果超过重传次数5次（每次间隔时间重传1+2+4+8+16+32=63s）的话，系统就把这个连接从半连接队列里面删除，释放这个半连接。

## SYN攻击

服务端的资源分配是第二次握手的时候分配的，攻击者可以伪造大量不存在的ip地址，然后在第一次握手的时候向服务端不断的发送SYN数据包，服务端就会回复SYN-ACK，然后把这个半连接放进半连接队列里面，服务端需要不断重试直到这些半连接达到重试次数才会把这个半连接移出队列，所以如果有大量的这种半连接占用半连接队列占满的话，正常的连接请求会因为半连接队列已经满了被丢弃。

防范方法：

1. 增大半连接队列的大小
2. 减少服务端重试次数
3. SYN Cookies：先不分配资源，先根据SYN包计算出一个cookies值作为SYN-ACK的初始序列号，等到客户端回复ack包，根据包头信息计算cookie是否和初始序列号+1比较，如果相同再分配资源建立连接

# TCP 四次挥手

TCP四次挥手

![img](D:\Acan\canwork\Note-master\网络.assets\v2-6e5f05603526c1d259b300f20b8857a5_720w.jpg)

1. 客户端->服务端（FIN=1 && seq=u）客户端由ESTABLISHED转化为FIN-WAIT-1  ps：u为此前客户端发送的最后一个字节的序号+1
2. 服务端->客户端（ACK=1 && seq=v && 确认号:u+1）服务端由ESTABLISHED转化为CLOSE-WAIT，客户端接收到之后由FIN-WAIT-1转化为FIN-WAIT-2，这时候服务端还能继续发送数据，客户端还能继续接收数据  ps：v为此前服务端发送的最后一个字节的序号+1
3. 服务端->客户端（FIN=1 && ACK=1 && seq=v+n && 确认号:u+1）服务端由CLOSE-WAIT转化为LAST-ACK，客户端接收之后由FIN-WAIT-2转化为TIME-WAIT  ps：v+n，如果半关闭状态没有发送数据的话，n为0
4. 客户端->服务端（ACK=1 && seq=u+1 &&  确认号:v+n+1） 客户端转化为TIME-WAIT阶段等待2MSL后关闭连接，服务端收到之后关闭连接。

## 为什么挥手需要四次？

在关闭连接的时候，客户端发起FIN请求，这时候服务端可能还有数据需要发送，所以先回一个ACK，等数据发送完了之后再回一个FIN+ACK，得把回应拆成两步，所以有四次。如果三次挥手的话可能导致数据丢失或者处理业务数据时间过长导致客户端fin重传

## 为什么最后需要等待2MSL?

MSL是最大报文存活时间，超过这个时间的报文都会被丢弃。

1. 保证客户端发送的最后一个ACK能够到达服务端。因为最后一个ACK可能会丢失，服务端会触发超时重传，重传FIN+ACK，客户端在等待的这段时间能够回应服务端，如果客户端没等待就关闭连接了，就会造成无法回复服务端的FIN+ACK，会导致服务端没办法正常关闭。
2. 客户端需要保证在本次连接中的所有报文都消亡，保证下一个新的连接中不会出现旧连接中的旧报文。

# TCP怎么保证可靠传输？

1. **按序到达**，使用以字节为单位的滑动窗口，TCP将要发送的字节进行一个编号，使用滑动窗口协议对字节进行传输，发送方发送滑动窗口中的字节，接收方对接收的字节进行一个校验和累积确认，发送方接收到确认之后移动窗口，发送接下来的字节。
2. **超时重传**，如果发送方收不到接收方的确认，超过一定时间就会触发超时重传机制。为了解决一定得超时才触发重传的弊端就出现了**快速重传**，就是发送端连续接收到某个序列号的ACK包的话就立刻重传这个序列号和序列号之后的字节。为了让发送方知道接收方接受了哪些字节，不用做没意义的重传，就可以使用**选择重传**，使用tcp首部的选项来存放这些信息，发送方接收到接收方的ACK的时候就能知道哪些包丢了哪些包没丢，只需要重传哪些字节就行，避免没意义的重传。
3. **流量控制**，避免发送方发送的太快，导致接收方来不及接收导致的丢包。在通信的过程中，接收方根据接收缓存中可用缓存的大小动态的调整发送方窗口的上限值，接收方将自己可用的接收缓存的大小写到tcp首部的窗口字段，发送方根据这个字段来调整发送的速率。ps：当接收方传回的窗口值为0，那么发送方将停止发送数据，如果发送方还有数据要发送的话，会周期性的向接收方发送窗口探测，强制接收方回复可接收的窗口大小。

# TCP的滑动窗口实现流量控制

**TCP 利用滑动窗口实现流量控制。==流量控制是为了控制发送方发送速率，保证接收方来得及接收。==** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”

1）对于TCP会话的发送方，任何时候在其发送缓存内的数据都可以分为4类：

- “已经发送并得到对端ACK的”，数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。
- “已经发送但还未收到对端ACK的”，已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。
- “未发送但对端允许发送的”
- “未发送且对端不允许发送”

2）对于TCP的接收方，在某一时刻在它的接收缓存内存在3种。“已接收”，“未接收准备接收”，“未接收并未准备接收”（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。其中“未接收准备接收”称之为接收窗口。

> TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。

# TCP拥塞控制

==拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。==防止发送太多数据包，导致时延、丢包发生重传，然后丢失更多的包，恶性循环。

发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的 概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。

发送方维护了一个拥塞窗口cwnd的状态变量和一个慢启动门限ssthresh（一般来说 ssthresh 的大小是 65535 字节。）

1. **慢启动**，拥塞窗口先设为1个MSS（最大报文长度），然后发送，收到确认之后，拥塞窗口为2（可以发送2个mss大小的数据），再发送，再收到确认之后，拥塞窗口变为4，呈指数的上升，当超过慢启动门限的时候改为拥塞避免算法。
2. **拥塞避免**，发送，收到确认之后，拥塞窗口+1，呈线性增长。当出现网络拥塞的时候，触发了重传机制，也就进入了「拥塞发生算法」。
3. 拥塞发生算法（两种）
   * 超时重传的拥塞发生算法：重传计时器超时，慢启动门限ssthresh 设为 cwnd/2 ，当前cwnd 重置为 1。带来的缺点：网络突然卡顿
   * 快速重传的拥塞发生算法：收到三个重复确认，TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下： cwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd ; 进入快速恢复算法进入，
4. 快速恢复算法如下： 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 重传丢失的数据包； 
   * 如果再收到重复的 ACK，那么 cwnd 增加 1； 
   * 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新 的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进入拥塞避免状态；（为了避免拥塞不严重过大减小拥塞窗口，导致tcp传输效率下降）

<img src="C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210325165212586.png" alt="image-20210325165212586" style="zoom:70%;" />

> 慢启动门限：就是超过慢启动门限就会进入拥塞避免算法
>
> 拥塞窗口 cwnd 变化的规则：只要网络中没有出现拥塞， cwnd 就会增大； 但网络中出现了拥塞， cwnd 就减少；
>
> 网络拥塞：如果出现重传计时器超时或者收到三个重复确认的话，发送方就认为出现了网络拥塞。

-----

# Http

请求报文：

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 最后是请求的内容主体

# 常见状态码

![image-20210319104250883](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210319104250883.png)

# get请求和post请求的区别？

* http报文层面：get将请求信息放在urL，post放在报文体中
* 资源方面：Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。 POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。
* GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据 就会创建多个资源，所以不是幂等的
* 其他层面：GET可以被缓存、被存储，而post不行

# 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)

> 打开一个网页，整个过程会使用哪些协议？

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg" style="zoom:50%;" />

> 上图有一个错误，请注意，是OSPF不是OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议

总体来说分为以下几个过程:

1. DNS解析（找到ip）
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

具体可以参考下面这篇文章：

- [https://segmentfault.com/a/1190000006879700](https://segmentfault.com/a/1190000006879700)

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器 但在发送之前，还有一项工作需要完成，那就是查询服务器域名对应的 IP 地址

客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路 顺藤摸瓜找到位于下层的某台目标 DNS 服务器

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。

# HTTP长连接,短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，**就建立一次连接，任务结束就中断连接**。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，**客户端和服务器之间用于传输HTTP数据的TCP连接不会立即关闭**，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：

- 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。
- 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。
- 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
- 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。** 

—— [《HTTP长连接、短连接究竟是什么？》](https://www.cnblogs.com/gotodsp/p/6366163.html)

# Cookie的作用是什么?和Session有什么区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session-id 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

![image-20210319104908638](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210319104908638.png)

# https

![image-20210319105920533](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210319105920533.png)

# HTTP 和 HTTPS 的区别？

1. 安全：HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全 的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。 
2. 资源：HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。
3. 端口：HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. 证书：HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

> HTTP 由于是明文传输，所以安全上存在以下三个风险：
>
> *  窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
> *  篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。 
> * 冒充风险，比如冒充淘宝网站，用户钱容易没。
>
> HTTPS:
>
> * 信息加密：混合加密的方式实现信息的机密性
> * 校验机制：摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完 整性，解决了篡改的风险。
> * 数字证书：将服务器公钥放入到数字证书中，解决了冒充的风险。
>
> HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：
>
> * 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 
>
> * 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。
>
>   ——》采用「混合加密」的方式的原因： 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但 速度慢。

# SSL/TLS四次握手

1. 客户端 Client Hello （支持的协议版本，客户端随机数Client Random后面用于生产会话密钥，支持的加密算法比如RSA）
2. 服务端 Sever Hello （确认加密协议版本，服务端随机数 Server Random，确认加密算法，服务器数字证书）
3. 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的 真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文（随机数pre-master key被公钥加密，通知接下来会话密钥加密通信，做个摘要，用来供服务端校验，握手结束通知）
4. 服务端回应（加密通信算法改变通知，握手结束通知）

整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普 通的 HTTP 协议，只不过用「会话秘钥」加密内容。

# 加密

对称加密：加密和解密都使用同一个密钥

非对称加密：加密使用的密钥和解密使用的密钥是不同的

哈希算法：将任意长度的信息转换成固定长度的值，算法不可逆

数字签名：证明某个信息或者文件时某人发出认同的

# HTTP 1.0和HTTP 1.1的主要区别是什么?

> 这部分回答引用这篇文章 <https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?> 的一些内容。

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **长连接** : **在HTTP/1.0中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**HTTP 1.1起，默认使用长连接** ,默认开启Connection： keep-alive。 **HTTP/1.1的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
1. **错误状态响应码** :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
1. **缓存处理** :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
1. **带宽优化及网络连接的使用** :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

http2.0成本高一般不使用 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基 于 UDP 的 QUIC。

#rsa

RSA算法一直是最广为使用的"非对称加密算法"（只要私钥不泄漏，通信就是安全的）

　　（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。只有私钥可以解开公钥加密的信息。

　　（2）甲方获取乙方的公钥，然后用它对信息加密。

　　（3）乙方得到加密后的信息，用私钥解密。

#xss攻击

通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序

解决方法：

- 首先是过滤。对诸如<script>、<img>、<a>等标签进行过滤。
- 其次是编码。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。
- 最后是限制。通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。