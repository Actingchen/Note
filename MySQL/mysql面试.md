部分来源: 极客时间MySQL实战45讲 丁奇 和NaNrailgun 

**三大范式**

第一范式 -----> 表的每一列都要保持它的原子性，也就是列不能再被分割。

1NF是对属性的**原子性**

第二范式 -----> 有主键 非主键列都需要依赖主键。

2NF是对记录的**惟一性**

第三范式 -----> 非主键列不能依赖于其他非主键列。

3NF是对字段的**冗余性**，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；

**架构**

1. 连接器与客户端建立TCP连接，验证账号密码。如果认证通过则查找这个用户的权限，正式建立这个数据库连接。（这个连接就依赖此时读到的权限。其中管理员修改了权限需要重新登录才能生效)     连接分为长连接短链接（连接为MySQL抽象出来的一个能让我们操作数据库服务器的接口，其本质还是TCP连接）。长连接：客户端的操作的复用这条连接。短链接：每次执行完很少的几次操作就断开连接，下次查询再建立。（MySQL会将一些数据绑定到连接对象中，所以一个连接复用太久的话会导致内存占用过大，解决方法是关掉重连或者reset命令让连接恢复到刚建立的样子）mysql_reset_connection
2. 缓存缓存，8.0之后无查询缓存了
3. 分析器分析SQL语句，分析语法是否符合规范。
4. 优化器，有多种执行方案能实现目标，那么系统通过优化器选择最优方案。
5. 执行器，先判断下有没有权限，之后根据优化器提供的最优方案调用引擎接口。

**日志**

MySQL 里经常说到的 WAL 技术—— Write-Ahead Logging，先写日志，再写磁盘

- redolog

innodb实现的物理日志，用来保证数据库异常重启时数据不丢失和提升数据修改时的效率

InnoDB 的 redo log 是固定空间大小的，循环写。写满了，就擦掉最久	的部分。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe

- binlog

binlog，是Server层实现的，适用于所有引擎，记录所有表数据的修改和表结构变更的逻辑日志

binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

| 模式      | 内容                           | 优势                                                         | 劣势                                                         |
| --------- | ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| statement | 记录引起数据变更的SQL语句      | 没有记录实际数据，日志量少，性能好                           | uuid函数每次执行的结果都是不确定的，使用statement的binlog进行回放必然出现数据不一致 |
| row       | 记录每次变更数据的前后两次数据 | 可以绝对精准的还原                                           | 会导致binlog的体积很大，对于修改记录的字段大的操作来说记录日志的性能损耗很大 |
| mixed     | statement和row两种模式混合     | 一般操作使用statement记录，涉及uuid等不确定的结果使用row模式 |                                                              |

- 两阶段提交(一条更新语句是怎么执行的)

给ID=2 的某个同行的字段属性加1，比如c     update T set c=c+1 where ID=2;

1、执行器先找到引擎ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就是直接返回执行器；否则，需要先从磁盘读入内存，然后再返回。

2、执行器拿到了引擎给的行数据，把c值加1，得到新的一行数据，再调用引擎接口写入这行数据。

3、当引擎拿到这行数据，它会将这行数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。

4、执行器会生成这个操作的binlog，并把binlog写入磁盘。

5、执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交状态，更新完成

> 1 prepare阶段 2 写binlog 3 commit
> 当在2之前崩溃时
> 重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。
> 一致
> 当在3之前崩溃
> 重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致

- undolog 回滚日志

1. insert undo log ：插入新纪录的时候产生的undolog，只在事务回滚时需要，在事务提交之后就能丢弃。
2. update undo log ：更新或删除数据时产生的undolog，在事务回滚的时候需要，在快照读的时候也需要，只有在快照读和事务回滚不涉及该日志的时候才能被删除。

实现机制

* 悲观锁（数据库）
  * 共享锁：事务A对某数据加了共享锁之后，其它事务只能对该数据加共享锁，但不能加排他锁
  * 排他锁：事务A对某数据加了排他锁之后，其它事务对该数据不能加共享锁也不能加排他锁。
* 乐观锁
  * 版本号、时间戳

**ACID**

**a：原子性**

使用commit和rollback实现，Innodb使用undoLog实现回滚，如果正在进行一个事务，Innodb会把这个事务的修改记录到undoLog中，如果需要回滚则使用这个事务的undoLog进行事务回滚。

**d：持久性**

Innodb使用redolog实现持久性。MySQL对于数据的修改，先写内存和redolog再用binlog写进磁盘。当数据库宕机的时候能通过redolog恢复，保证了持久性。

**I：隔离性**（脏写在所有隔离级别下都得避免）

读未提交（导致脏读，不可重复读，幻读）

读提交（导致不可重复读，幻读）

可重复读（导致幻读）

串行化

1. 读未提交。（读不加锁。写加锁，事务结束释放锁）
2. 读提交。（读sql时快照，已提交的事务可见，其他不可见。写加锁，事务结束释放锁）
3. 可重复读。（读，事务开启时快照。写加锁，使用next-key锁，之前两种都是行锁，事务结束解锁）（MySQL使用快照读和next-key lock解决了幻读）

版本未提交，不可见；

版本已提交，但是是在视图创建后提交的，不可见；

版本已提交，而且是在视图创建前提交的，可见。

1. 串行化。（读加共享锁。写加互斥锁，数据冲突时事务为串行执行）

**c：一致性**

通过以上三点保证一致性和业务层面保证一致性。

**事务**

脏读、不可重复读、幻读

第一类丢失更新：两个事务更新同一条数据资源，某一事务完成，另一事务异常终止，回滚造成前面一个事务完成的更新也同时丢失 。

脏读:可以读到其他事务未提交的数据； 

不可重复读：在事务中前后读取的记录内容不一致； 

幻读：刚开始读发现不存在然后插入，但是发现插入失败导致在事务中前后读取的记录数量（集合）不一致——“幻读”（rr模式下引入了间隙锁解决当前读下的幻读问题，快照读是mvcc解决的）。幻读是新增了满足/不满足当前查询条件的行，导致前后查询结果不一致。

第二类丢失更新：在不可重复读有一种特殊情况，两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失

事务隔离级别：

1. 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。不能防止第一类更新丢失问题，不能解决脏读，不可重复读及幻读问题
2. 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。可以防止脏读问题，但会出现不可重复读及幻读问题
3. 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。可以防止除幻读外的其他问题（MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。）（当然，后来引入了间隙锁解决当前读的幻读问题）
4. 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。从而解决幻读、第二类更新丢失问题在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争

![image-20210206204753704](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210206204753704.png)

**当前读和快照读**

当前读是指读取当前（字段c）最新版本的值，并且读取时保证其它并发事务不能修改（字段c）值。

快照读的实现是基于多版本并发控制，就是mvcc

InnoDB 给每一个事务生成一个唯一事务 ID 的方法称为生成快照，因此这种场景称为**快照读**。

但是对于更新数据不能使用快照读，因为更新数据时如果使用快照读会可能会覆盖其他事务的更改。

另外查询时如果加锁也会采用当前读的方式。**当前读**就是读这个数据最新的提交数据。

其中幻读在快照读被mvcc解决，当前读被间隙锁加记录锁即next key临键锁解决

**mvcc**

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 同时还可以解决脏读，幻读（读时幻读，写的幻读没有解决），不可重复读等事务隔离问题，但不能解决更新丢失问题

mvcc是靠3个隐式字段，undo日志 ，Read View实现的

注意：可重复读 -- 事务开始时创建ReadView. 读提交 -- 事务每个语句都创建新的ReadView

**索引**

一个索引一个B+树，非叶子节点存储的是key，叶总节点存储的key和value

主键索引： key:主键的值，value:整行数据。 

普通列索引： key：索引列的值， value:主键的值。

基于主键索引和普通索引的查询有什么区别？

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；

如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

1、覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据

2、最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。例如索引是key index (a,b,c). 可以支持a a,b a,b,c 3种组合进行查找，但不支持 b,c进行查找。

3、联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。

4、索引下推：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度。【索引下推】Index Condition Pushdown，简称 ICP。 是Mysql 5.6版本引入的技术优化。旨在 在“仅能利用最左前缀索的场景”下（而不是能利用全部联合索引），对不在最左前缀索引中的其他联合索引字段加以利用——在遍历索引时，就用这些其他字段进行过滤(where条件里的匹配)。过滤会减少遍历索引查出的主键条数，从而减少回表次数，提示整体性能。

5、**全表扫描**：通常在数据库中，对无索引的表进行查询一般称为全表扫描；然而有时候我们即便添加了索引，但当我们的SQL语句写的不合理的时候也会造成全表扫描。 使用null做为判断条件、使用or做为连接条件 、！= 或<>、只有模糊匹配时、使用in时(或not in) 使用count(*)时 

**用B+树不用B树的原因/区别**

（1）叶子节点 前后指针 范围查询方便

（2） https://www.cnblogs.com/nullzx/p/8978177.html

因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。而B+树具体的数据都存在叶子节点上，同时叶子节点还有前后指针能存储更多的索引值，能进一步压缩树的高度，减少磁盘IO次数。

当我们要在磁盘上索引一个记录时，将磁盘中的数据传输到内存中才是花费时间的大头，在内存中的索引过程所花的时间基本是可以忽略不计的。在磁盘中以B+树的形式组织数据就有着天然的优势。减少磁盘io次数。（根节点是常驻内存的）（树高其实取决于叶子树（数据行数）和“N叉树”的N。 而N是由页大小和索引大小决定的。）

**MySQL的锁**

**全局锁**，锁库

**表锁**，顾名思义锁表

**mdl**

当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

sessionC（DDL操作【删除表中列】）被前面的sessionA和B（查询操作，获取MDL 读锁）所阻塞。这里sessionC的DDL操作任务肯定是处于等待的，后续来的sessionD（查询操作）为什么会被sessionC所阻塞？sessionC现在都还没有进行DDL操作，没有获取到MDL写锁，为什么sessionD会被C阻塞？mysql Server端对于sessionC，D有一个 队列 来决定谁先执行。

办法：在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。然后再人为重试。

[**DDL和DML的定义和区别**](https://www.cnblogs.com/nyist-xsk/p/7264775.html)

DML(Data Manipulation Language)数据操纵语言：

适用范围：对数据库中的数据进行一些简单操作，如insert,delete,update,select等.

DDL(Data Definition Language)数据定义语言：

适用范围：对数据库中的某些对象(例如，database,table)进行管理，如Create,Alter和Drop.

区别：

1.DML操作是可以手动控制事务的开启、提交和回滚的。

2.DDL操作是隐性提交的，不能rollback！

**意向锁**

如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。

InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁共存。

意向锁之间互不排斥，但除了 IS 意向共享锁与 S 共享锁兼容外，其他意向锁会与 共享锁 / 排他锁 互斥。

​             意向共享锁（IS）	意向排他锁（IX）

共享锁（S）	兼容	互斥

排他锁（X）	互斥	互斥

IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。

意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。

**记录锁 间隙锁 临键锁**

1. 记录锁、间隙锁、临键锁，都属于排它锁；
2. 记录锁就是锁住一行记录；
3. 间隙锁只有在事务隔离级别 RR 中才会产生；
4. 唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁；
5. 普通索引不管是锁住单条，还是多条记录，都会产生间隙锁； 
6. 间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其它事务在这个区域内插入、修改、删除数据，这是为了防止出现 幻读 现象；
7. 普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序（多普通索引情况还未研究）；
8. 事务级别是RC（读已提交）级别的话，间隙锁将会失效。

在深入了解了之后... 我发现这是一个局促索引和非聚簇索引在🔒方面的不同表现... 聚簇索引中不会出现key重复的情况，而非聚簇索引则不然，因此针对聚簇索引枷锁的时候，如果目标是明确的，仅仅锁一个key就可以了，但是非聚簇索引为了防止相同的key插入，会把目标key的左右两边都锁住

https://www.cnblogs.com/crazylqy/p/7821481.html

https://zhuanlan.zhihu.com/p/48269420

**慢查询**

**介绍**

全名是慢查询日志，记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下不启动，需要我们手动来设置这个参数，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。

**常见慢查询的原因：**

1没有用到索引

2出现死锁

3返回了不必要的行或列，一般查询SQL语句一定要将字段明确指定。而不要使用*进行查询

4注意UNion和UNion all 的区别。UNION all好

**explain**

explain用于SELECT语句中的涉及到的每个表返回一行信息。表是按照它们在处理查询过程中被MySQL读入的顺序被列出。

possible_keys（可能使用哪个索引）  key（实际使用的索引） key_len（索引长度）

**最左匹配原则**

最左匹配原则都是针对联合索引来说的，注意此时数据库依据联合索引最左的字段来构建 B+ 树。比如查(a,b,c)联合索引，那么a 是有序的，而 b，c 都是无序的。但是当在 a 相同的时候，b 是有序的，b 相同的时候，c 又是有序的。

**in和exits的区别**

in在查询的时候，首先查询子查询的表 然后按照条件进行筛选。所以相对内表比较小或者子查询得出的结果集记录较少的时候，in的速度较快。

exits先查我们的主查询的表 然后按照条件进行筛选。所以相对外表比较小的时候，exits的速度较快。

**union /union all**

union all为（直接将两个查询结果集合并）

union 运算结果为（两个结果集合并后进行去重/distinct）

复合索引失效

**索引设计的原则**

1. 服从最左原则
2. 避免索引冗余
3. 选用区分度高的字段建索引

**聚簇索引和非聚簇索引**

innodb的主键就是聚簇索引，数据存储与索引放到了一块，找到索引也就找到了数据 数据的物理存放顺序与索引顺序是一致的

myISAM 主键还是二级索引都是非聚簇索引。非聚簇索引是通过索引的查找找需要的表的数据的地址，地址在磁盘上存储的位置不一定连续

**MyIASM 和 InnoDB 的区别**

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；
3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

**数据库中怎么避免死锁？**

1）以固定的顺序访问表和行。即按顺序申请锁，这样就不会造成互相等待的场面。

2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。

3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。

4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

5）为表添加合理的索引。如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

join

在这个 join 语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。

显然，N 对扫描行数的影响更大，因此应该让小表来做驱动表