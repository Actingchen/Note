# 讲一下你对jvm的理解

##jvm是什么

jvm屏蔽了操作系统和java的直接交互，jvm是jdk编译后的二进制字节码的运行环境，依靠里面对不同操作系统的特定实现

- 一次编写，到处运行

另外

- 自动内存管理，垃圾回收机制
- 数组下标越界检查

##jvm的内存模型

除了堆和方法区是线程共享区，其余3个是私有的。

###程序计数器

> 作用

用于保存JVM中下一条所要执行的指令的地址

> 特点

- 线程私有
  - CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码
  - 程序计数器是**每个线程**所**私有**的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令
- 不会存在内存溢出

###虚拟机栈

> 定义

- 每个**线程**运行需要的内存空间，称为**虚拟机栈**
- 每个栈由多个**栈帧**组成，对应着每次调用方法时所占用的内存
- 每个线程只能有**一个活动栈帧**，对应着**当前正在执行的方法**

###本地方法栈

一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法

### 堆

> 定义

通过new关键字**创建的对象**都会被放在堆内存

> 特点

- **所有线程共享**，堆内存中的对象都需要**考虑线程安全问题**
- 有垃圾回收机制

### 方法区

> 定义

Java虚拟机中有一个被所有jvm线程共享的方法区。方法区有点类似于传统编程语言中的编译代码块或者操作系统层面的代码段。它存储着每个类的构造信息，譬如运行时的常量池，字段，方法数据，以及方法和构造方法的代码，包括一些在类和实例初始化和接口初始化时候使用的特殊方法。

方法区在jvm启动时候被创建。虽然方法区在逻辑层面上是堆的一部分，但是既不会被回收也不会被压缩。方法区可能有一个固定的大小或者也可以通过计算大小去扩展也可以在不需要的时候被压缩。方法区的内存也不需要是连续的。

Jvm虚拟机实现可以提供给编程人员或者用户初始化方法区的大小，同时在方法区可变大小的情况下，控制这个方法区的最大值和最小值。

如果方法区满足不了构造所需要的内存，jvm就会抛出OutOfMemoryError。

> 有什么

1.6的时候放在永久代，它有class classloader 常量池、串池

1.8的时候放在元空间，class classloader 常量池放在了元空间 （也就是本地内存 【物理内存】），但运行时常量池和串池都移动到堆中

- 常量池

  - 就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息

- 运行时常量池

  - 常量池是*.class文件中的，当该**类被加载以后**，它的常量池信息就会**放入运行时常量池**，并把里面的**符号地址变为真实地址**

- 字符串常量池/串池

  * 这是JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为字符串开辟一个字符串常量池，类似于缓存区。

    当我们使用双引号创建一个字符串时，首先在字符串常量池中查找是否有相同值的字符串，如果发现则返回其引用，否则它会在池中创建一个新的字符串，然后返回新字符串的引用。

    如果使用new运算符创建字符串，则会强制String类在堆空间中创建一个新的String对象。

>intern方法 1.8

调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中

- 如果串池中没有该字符串对象，则放入成功
- 如果有该字符串对象，则放入失败

无论放入是否成功，都会返回**串池中**的字符串对象

> intern方法 1.6

调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中

- 如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中
- 如果有该字符串对象，则放入失败

无论放入是否成功，都会返回**串池中**的字符串对象

#### StringTable调优

- 因为StringTable是由HashTable实现的，所以可以**适当增加HashTable桶的个数**，来减少字符串放入串池所需要的时间

  ```
  -XX:StringTableSize=xxxxCopy
  ```

  

- 考虑是否需要将字符串对象入池

  可以通过**intern方法减少重复入池**，比如大量重复地址信息尝试intern方法

# 内存泄漏和内存溢出

- 内存泄漏：系统分配的内存没有被回收。
- 内存溢出：分配的内存空间超过系统内存
- **内存泄漏**会导致可用的内存减少，进而会导致**内存溢出**

#jvm的内存溢出

## 虚拟机栈OOM——栈溢出

**发生原因**

- 1、虚拟机栈中，**栈帧过多**（无限递归）
- 2、每个栈帧**所占用过大**

## 本地方法栈

1. 程序创建的线程数超过操作系统的限制。
2. JVM占用的内存太多，导致创建线程的内存空间太小。

##堆OOM

存活的对象超过内存大小

##方法区OOM

- 过多使用了Static修饰
- 1.8以前会导致**永久代**内存溢出
- 1.8以后会导致**元空间**内存溢出

# 直接内存

- java没办法直接读取文件，需要用户态切换成内核态
- 为了不设置系统缓存、jvm缓存过多的缓冲区，直接内存是操作系统和Java代码**都可以访问的一块区域**，常见于NIO操作时，**用于数据缓冲区** 从而提高了效率
- 分配回收成本较高，但读写性能高
- 不受JVM内存回收管理
- 也会导致内存溢出

# jvm排查

##线程运行诊断

CPU占用过高

- Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程
  - **top**命令，查看是哪个**进程**占用CPU过高
  - **ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号** 通过ps命令进一步查看是哪个线程占用CPU过高
  - **jstack 进程id** 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来**对比定位**，注意jstack查找出的线程id是**16进制的**，而ps下的tid是十进制，**需要转换** 。看其中信息可以知道定位到具体代码，比如哪行代码导致cpu很高或者哪行导致死锁。

##堆内存、死锁等诊断

* windows下 jdk/bin 下 cmd

* jps

  > jps是查看java进程信息的命令

* jmap -heap pid

  > 查看堆内存情况（只能查某一时刻）

* jconsole

  > 图形界面，可以多功能连续监测 也可以检测死锁

* jvisualvm（j v shou vm）

  > 垃圾回收之后仍然内存很高 
  >
  > 特别功能 它也可以监视 点堆dump 生成快照 收集信息保存起来 生成的快照也可以查找前最大多少个对象以及具体对象的占用情况 

# 类加载

![img](https://static.oschina.net/uploads/space/2017/1217/151936_zTy4_3735426.png)

java 类加载需要经历一下 7 个过程： 

> 加载

加载 加载时类加载的第一个过程，在这个阶段，将完成一下三件事情： 1. 通过一个类的全限定名获取该类的二进制流。 2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 3. 在内存中生成该类的 Class 对象，作为该类的数据访问入口。

> 验证

验证 验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成 以下四钟验证: 1. 文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟 机范围内，常量池中的常量是否有不被支持的类型. 2. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不 被继承的类等。 3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析， 确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转 指令是否正确等。 4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执 行。

>准备

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进 行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象 一起分配在 Java 堆中。

>解析

该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之 前，也有可能在初始化之后。

>初始化

初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过 自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正 开始执行类中定义的 Java 程序代码。

#Minor GC、Major GC、Full gc

##1.Minor GC

Minor GC是指从新生代空间（包括 Eden 和 Survivor 区域）回收内存。

回收过程：采用复制算法

首先把**Eden区和Survivor From区域中存活的对象复制到Survivor To中**（如果有对象的年龄达到了老年的标准，直接存在老年区），同时把这些对象的年龄+1（如果Survivor To内存不够了，就放到老年代）,然后在将Eden区和Survivor From区清理，最后Survivor From和Survivor To互换，Survivor To成为下一次GC时的Survivor From区，无论啥时候，都有一块空闲的Survivor区。

触发条件：
(1)当Eden区满时。
(2)新创建的对象的大小大于Eden区剩余的空间时。

##2.Major GC

Major GC是指从老年代回收内存

回收过程：标记—清除算法，标记—整理算法

老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。

##3.Full GC

- Full GC清理整个堆内存区，包含了新生代和老年代。
- 触发条件
  （1）调用System.gc时，系统建议执行Full GC，但是不必然执行
  （2）老年代空间不足
  （3）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  （4）在新生代回收内存时，由Eden区和Survivor From区把存活的对象向Survivor To区**复制时**，**对象大小大于Survivor To空间的可用内存**，则把该对象转存到老年代（这个过程称为分配担保），且老年代的可用内存小于该对象大小。即老年代无法存放下新年代过度到老年代的对象的时候，便会触发Full GC。

Major GC/Full GC 区别不大

#回收策略

新生代里分为伊甸园区 幸存区from 幸存区to

老年代

经历一次gc 年龄就加1

1. 对象优先在堆的 Eden 区分配。 
2. 大对象直接进入老年代. 
3. 长期存活的对象，比如默认阈值年龄，最大是15，将直接进入老年代. 当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通 常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高， 回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。

# stw

gc都会触发stw，暂停其他用户线程

minor gc比较少时间，full gc stw 时间比较长

# 调优

###基本堆参数

![image-20210207155522914](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210207155522914.png)**新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )**

Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )

### GC 调优

查看虚拟机参数命令

```
"F:\JAVA\JDK8.0\bin\java" -XX:+PrintFlagsFinal -version | findstr "GC"Copy
```

可以根据参数去查询具体的信息

#### 调优领域

- 内存
- 锁竞争
- CPU占用
- IO
- GC

#### 确定目标

低延迟/高吞吐量？ 选择合适的GC

- CMS G1 ZGC
- ParallelGC
- Zing

#### 最快的GC是不发生GC

首先排除减少因为自身编写的代码而引发的内存问题

- 查看Full GC前后的内存占用，考虑以下几个问题
  - 数据是不是太多？
  - 数据表示是否太臃肿
    - 对象图
    - **对象大小**
  - 是否存在内存泄漏 static Map map 解决方法 软引用、弱引用 缓存用第三方缓存实现不耗费自己的内存

#### 新生代调优

- 新生代的特点
  - 所有的new操作分配内存都是非常廉价的
    - TLAB
  - 死亡对象回收零代价
  - 大部分对象用过即死（朝生夕死）
  - MInor GC 所用时间远小于Full GC
- 新生代内存越大越好么？
  - 不是
    - 新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降
    - 新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长
  - **新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜**

#### 幸存区调优

- 幸存区需要能够保存 **当前活跃对象**+**需要晋升的对象**
- 晋升阈值配置得当，让长时间存活的对象尽快晋升，让活跃但存活时间短的保存

#### 老年代调优

# 垃圾回收算法

pdf

# cms

pdf

# G1

pdf

补充：

同时注重吞吐量和低延迟，默认暂停目标是200ms,jdk9默认垃圾回收器

超大堆内存，会把堆划分为多个大小相等的区

整体上是标记+整理算法，两个区之间是复制算法