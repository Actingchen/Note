#  讲一下你对jvm的理解

## jvm是什么

jvm屏蔽了操作系统和java的直接交互，jvm是jdk编译后的二进制字节码的运行环境，依靠里面对不同操作系统的特定实现

- 一次编写，到处运行

## jvm的内存模型

* 除了堆和方法区是线程共享区，其余3个是私有的。

<img src="https://uploadfiles.nowcoder.com/files/20190110/7380095_1547132982417_2614605-246286b040ad10c1.png" alt="img" style="zoom:67%;" />

### 程序计数器

> 作用

用于保存JVM中下一条所要执行的指令的地址

字节码解释器通过改变程序计数器去依次读取指令，实现代码流程的控制。

程序计数器是用来记录线程运行位置的，当发生线程切换时能够通过程序计数器保存线程的运行位置。

> 特点

- 线程私有
  - CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码
  - 程序计数器是**每个线程**所**私有**的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令
- 不会存在内存溢出

### 虚拟机栈

> 定义

- 每个**线程**运行需要的内存空间，称为**虚拟机栈**
- 每个栈由多个**栈帧**组成，对应着每次调用方法时所占用的内存
- 每个线程只能有**一个活动栈帧**，对应着**当前正在执行的方法**
- 当方法结束的时候，这个栈帧就会从虚拟机栈里弹出。
- 栈帧存储了局部变量表，局部变量表存储了基本数据类型和对象引用
- **`StackOverFlowError`：** 栈深度溢出。
- **`OutOfMemoryError`：** 栈拓展失败。

<img src="https://img-blog.csdn.net/2018071122520040?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6cWFuemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 50%;" />

如果线程请求的栈深度超过虚拟机所允许的深度抛StackOverflowError，如果虚拟机栈的容量是允许动态拓展的时候，当栈拓展时无法申请到足够的内存抛OutOfMemoryError，如果其他线程被创建的时候虚拟机栈申请不到足够空间的时候也会抛OutOfMemoryError

### 本地方法栈

一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法。

###  堆

> 定义

通过new关键字**创建的对象**都会被放在堆内存

> 特点

- **所有线程共享**，堆内存中的对象都需要**考虑线程安全问题**
- 有垃圾回收机制

###  方法区

> 定义

Java虚拟机中有一个被所有jvm线程共享的方法区。方法区用于存储已被**虚拟机加载的类信息、常量、静态变量**等数据。

当方法区无法满足新的内存分配需求的时候抛OutOfMemoryError

为什么使用元空间代替永久代？

1.永久代有一个jvm本身设置的大小上限，无法进行调整。元空间使用的是直接内存吗，受本机可用内存限制，虽然元空间还是有内存溢出的风险，但比原来出现的机率要小很多。当你元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`

2.因为元空间可以做到只受系统内存大小的限制，所以能加载的类就更多了。

> 有什么

1.6的时候放在永久代，它有class classloader 常量池、串池

1.8的时候放在元空间，class classloader 常量池放在了元空间 （也就是本地内存 【物理内存】），但运行时常量池和串池都移动到堆中

- 常量池

  - 就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息

- 运行时常量池

  - 常量池是*.class文件中的，当该**类被加载以后**，它的常量池信息就会**放入运行时常量池**，并把里面的**符号地址变为真实地址**

- 字符串常量池/串池

  * 这是JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为字符串开辟一个字符串常量池，类似于缓存区。

    当我们使用双引号创建一个字符串时，首先在字符串常量池中查找是否有相同值的字符串，如果发现则返回其引用，否则它会在池中创建一个新的字符串，然后返回新字符串的引用。

    如果使用new运算符创建字符串，则会强制String类在堆空间中创建一个新的String对象。

>intern方法 1.8

调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中

- 如果串池中没有该字符串对象，则放入成功
- 如果有该字符串对象，则放入失败

无论放入是否成功，都会返回**串池中**的字符串对象

> intern方法 1.6

调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中

- 如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中
- 如果有该字符串对象，则放入失败

无论放入是否成功，都会返回**串池中**的字符串对象

####  StringTable调优

- 因为StringTable是由HashTable实现的，所以可以**适当增加HashTable桶的个数**，来减少字符串放入串池所需要的时间

  ```
  -XX:StringTableSize=xxxxCopy
  ```

- 考虑是否需要将字符串对象入池

  可以通过**intern方法减少重复入池**，比如地图软件，大量使用重复地址信息可以尝试intern方法

#  内存泄漏和内存溢出

- 内存泄漏：系统分配的内存没有被回收。
- 内存溢出：分配的内存空间超过系统内存
- **内存泄漏**会导致可用的内存减少，进而会导致**内存溢出**

# jvm的内存溢出

##  虚拟机栈OOM——栈溢出

 发生原因

- 1、虚拟机栈中，**栈帧过多**（无限递归）
- 2、每个栈帧**所占用过大**

##  本地方法栈

1. 程序创建的线程数超过操作系统的限制。
2. JVM占用的内存太多，导致创建线程的内存空间太小。

## 堆OOM

存活的对象超过内存大小

## 方法区OOM

- 过多使用了Static修饰
- 1.8以前会导致**永久代**内存溢出
- 1.8以后会导致**元空间**内存溢出

#  直接内存

- java没办法直接读取文件，需要用户态切换成内核态
- 为了不设置系统缓存、jvm缓存过多的缓冲区，直接内存是操作系统和Java代码**都可以访问的一块区域**，常见于NIO操作时，**用于数据缓冲区** 从而提高了效率
- 分配回收成本较高，但读写性能高
- 不受JVM内存回收管理
- 也会导致内存溢出

# jvm排查

##线程CPU占用过高诊断

CPU占用过高

- Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程
  - **top**命令，查看是哪个**进程pid**占用CPU过高
  - **ps H -eo pid, tid（线程tid）, %cpu | grep 刚才通过top查到的进程号** 通过ps命令进一步查看是哪个线程占用CPU过高
  - **jstack pid** 注意jstack查找出的结果信息中线程nid是**16进制的**，先把之前ps看到的tid的十进制转成16进制。看其中信息可以知道定位到具体代码，比如哪行代码导致cpu很高或者哪行导致死锁。

##堆内存、死锁等诊断

* windows下 jdk/bin 下 cmd

* jps

  > jps是查看java进程信息的命令

* jmap -heap pid

  > 查看堆内存情况（只能查某一时刻）

* jconsole

  > 图形界面，可以多功能连续监测 也可以检测死锁

* jvisualvm（j v shou vm）

  > 垃圾回收之后仍然内存很高 
  >
  > 特别功能 它也可以监视 点堆dump 生成快照 收集信息保存起来 生成的快照也可以查找前最大多少个对象以及具体对象的占用情况 

## OOM排查

一般手段是：先通过内存映像工具对Dump出来的堆转储快照进行分析，**重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。**

- 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。这样就能够找到泄漏的对象是通过怎么样的路径与GC Roots相关联的导致垃圾回收机制无法将其回收。掌握了泄漏对象的类信息和GC Roots引用链的信息，就可以比较准确地定位泄漏代码的位置。
- 如果不存在泄漏，那么就是内存中的对象确实必须存活着，那么此时就需要通过虚拟机的堆参数（ -Xmx和-Xms）来适当调大参数；从代码上检查是否存在某些对象存活时间过长、持有时间过长的情况，尝试减少运行时内存的消耗。

# 类加载

![img](https://static.oschina.net/uploads/space/2017/1217/151936_zTy4_3735426.png)

> 加载

加载 加载时类加载的第一个过程，在这个阶段，将完成一下三件事情： 1. 通过一个类的全限定名获取该类的二进制流。 2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 3. 在内存中生成该类的 Class 对象，作为该类的数据访问入口。

> 验证

验证 验证的目的是为了确保 Class 文件的字节流中的信息不会危害到虚拟机.在该阶段主要完成 以下四钟验证: 1. 文件格式验证 2. 元数据验证 3. 字节码验证 4. 符号引用验证

>准备

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进 行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象 一起分配在 Java 堆中。

>解析

将常量池中的符号引用转化为直接引用

>初始化

执行类的初始化方法<clinit>，静态代码块和赋初始值在这个方法里执行，对于这个方法的调用，jvm会保证多线程环境中的安全性，这个方法自带锁的，但有的时候在并发环境下初始化类会造成死锁。

一个类的初始化方法只会被执行一次，只会被初始化一次。

> 卸载

卸载类需要满足3个要求:

1. 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
2. 该类的Class对象没有在其他任何地方被引用
3. 该类的类加载器的实例已被GC

#Minor GC、Major GC、Full gc

##1.Minor GC

Minor GC是指从新生代空间（包括 Eden 和 Survivor 区域）回收内存。

回收过程：采用复制算法

首先gc后把**Eden区和Survivor From区域中存活的对象复制到Survivor To区中**（如果有对象的年龄达到了15/大对象，直接存在老年区），同时把这些对象的年龄+1（如果Survivor To内存不够了，就放到老年代）,然后在将Eden区和Survivor From区清理，最后Survivor From和Survivor To互换，Survivor To成为下一次GC时的Survivor From区，无论啥时候，都有一块空闲的Survivor区。

触发条件：
(1)当Eden区满时。
(2)新创建的对象的大小大于Eden区剩余的空间时。

##2.Major GC

Major GC是指从老年代回收内存

回收过程：标记—清除算法，标记—整理算法

老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。

##3.Full GC

- Full GC清理整个堆内存区，包含了新生代和老年代。
- 触发条件
  （1）调用System.gc时，系统建议执行Full GC，但是不必然执行
  （2）老年代空间不足
  （3）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  （4）在新生代回收内存时，由Eden区和Survivor From区把存活的对象向Survivor To区**复制时**，**对象大小大于Survivor To空间的可用内存**，则把该对象转存到老年代（这个过程称为分配担保），且老年代的可用内存小于该对象大小。即老年代无法存放下新年代过度到老年代的对象的时候，便会触发Full GC。

Major GC/Full GC 区别不大

#回收策略

**新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )**

Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )

新生代里分为伊甸园区 幸存区from 幸存区to

老年代

经历一次gc 年龄就加1

1. 对象优先在堆的 Eden 区分配。 
2. 大对象直接进入老年代. 
3. 长期存活的对象，比如默认阈值年龄，**最大是15，将直接进入老年代**. 当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通 常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高， 回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。

# stw

gc都会触发stw，暂停其他用户线程

minor gc比较少时间，full gc stw 时间比较长

#GC root

1、虚拟机栈（栈中的本地变量表）中引用的对象；

2、方法区中类静态属性引用的对象；

3、方法区中常量引用的对象；

4、本地方法栈中JNI（即一般说的Native方法）引用的对象。

# 调优

### GC 调优

#### 新生代调优

- 新生代的特点
  - 所有的new操作分配内存都是非常廉价的
    - TLAB
  - 死亡对象回收零代价
  - 大部分对象用过即死（朝生夕死）
  - MInor GC 所用时间远小于Full GC
- 新生代内存越大越好么？
  - 不是
    - 新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降
    - 新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长
  - **新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜**

#### 幸存区调优

- 幸存区需要能够保存 **当前活跃对象**+**需要晋升的对象**
- 晋升阈值配置得当，让长时间存活的对象尽快晋升，让活跃但存活时间短的保存

# 垃圾回收算法

复制算法

* 为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。当这一块的内存 使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内 存区间的一半进行回收

标记清除算法

* 它是最基础的收集算法，这个算法分为两个阶段，“标记”和”清除“。首先标记出所有需要回收的对象，在标记完成后 统一回收所有被标记的对象。
* 它有两个不足的地方： 1. 效率问题，标记和清除两个过程的效率都不高； 2. 空间问题，标记清除后会产生大量不连续的碎片；

标记整理算法

* 根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行 回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存

#CMS（标记清除算法）

是一种以获取最短停顿时间为目标的垃圾回收器，第一款真正意义上的并发收集器，他第一次实现了让垃圾收集线程和用户线程同时工作。

![image-20201106152642618](D:\Acan\canwork\Note-master\jvm.assets\image-20201106152642618.png)

工作流程

1.初始标记

stop the world，标记所有和gc root相连的对象，速度很快。

2.并发标记

并发标记的线程和用户线程一起运行，去遍历整个对象图，这个过程耗时比较长，但他并不需要停顿用户线程，可以并发执行。

3.重新标记

为了修正在并发标记期间因为和用户线程并发运行导致一些对象引用被用户线程修改，然后导致的对象标记改变的问题。（会比初始标记的时间稍长，但时间远远少于并发标记的时间）

4.并发清除

清除判断已经死亡的对象，这个阶段也可以和用户线程一起运行。

优点：并发收集，停顿时间短。

缺点：

1.对处理器资源敏感

如果本来应用的处理器负载就很高，使用CMS的话还需要分出一部分线程作为垃圾回收就可能导致用户程序的执行速度忽然大幅降低。

2.无法处理浮动垃圾

在并发标记和并发清除阶段和用户线程并发运行，这两个阶段用户线程产生的垃圾称为浮动垃圾，这部分垃圾只能等到下一次才能回收。所以CMS垃圾回收需要给用户线程预留一定的空间存放这些浮动垃圾。如果阈值设置太大的话，虽然能够预留足够空间去存储浮动垃圾，但垃圾回收程序会被频繁的激活；如果设置的阈值比较小的话，可能预留的空间无法存储浮动垃圾就会出现并发失败，这时候虚拟机会冻结用户线程，使用Serial Old来重新进行垃圾回收，如果频繁地出现并发失败的话对性能的影响是很严重的。==？？？？==

3.碎片空间

标记清除算法容易产生大量的碎片空间，导致大对象无法分配

#G1

![image-20201106220853537](D:\Acan\canwork\Note-master\jvm.assets\image-20201106220853537.png)

G1针对的是多核处理器和大容量的机器，实现可预期可配置的Stop The World停顿时间。

G1把内存空间划分为一个个Region，每一个区域可能是伊甸园，Survivor，或者老年代，同一个时刻只能是一种状态。G1还有为大对象分配的Humongous区域，一个或者多个Humongous可以分配大对象。

G1的特点：

1.分成一个个Region，不用回收整个年轻代或者老年代，还建立了可预测的时间模型，去回收价值最大的Region，实现可预测的停顿时间，保证了G1在有限的时间内尽可能高的收集效率。

2.使用标记复制算法，不会产生内存碎片。

解决跨Region引用：使用卡表和记忆集，卡表是记录了我指向谁，记忆集记录了谁指向我。

使用记忆集的原因是因为不能像跨代引用那样直接扫描老年代的卡表就行，因为Region非常多，不能扫描全部Region的卡表。

1.初始标记

标记一下与GC root 直接关联的对象，需要Stop The World，但时间很快。

2.并发标记

从GC root对堆中的对象进行可达性分析，垃圾收集线程与用户线程并发执行。

在并发标记阶段需要预留出一部分空间去存放新分配的对象，如果垃圾回收赶不上内存分配的话就会并发错误且触发Full GC导致长时间停顿。使用原始快照去防止并发标记时出错。

3.最终标记

对并发标记产生的原始快照进行处理？需要Stop The World。

4.筛选回收

更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户指定的期望时间指定回收计划，**然后将对应的Region使用标记复制的方法复制到空的Region中。需要Stop The World，因为涉及对象的移动。**

G1对比CMS

优点：

**G1针对年轻代和老年代，CMS只能用于老年代回收**（虽然是老年代的gc，但仍要扫描新生代，因为新生代可能有引用老年代对象）。

**G1可以指定期望的停顿时间，能回收价值最高的Region，保证回收效率。**

**G1宏观是一个标记整理算法，不会产生内存碎片。**

缺点：

G1消耗的额外cpu资源更多，消耗的额外内存更多。

Young GC：

在伊甸园空间耗尽时触发，每次Young GC会选定所有新生代Region，同时计算下次的Young GC所需的伊甸园和Survivor空间，动态控制Region的数量来控制Young GC

Mixed GC：

当老年代到达阈值的时候触发Mixed GC，选定所有年轻代Region，根据全局并发标记阶段得到的价值最高的老年代Region，然后依照用户指定的期望时间，选择价值较高的老年代Region进行回收。

由于G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整`-XX:MaxGCPauseMillis=N`参数，这也符合G1的目的——让GC调优尽量简单，这里有个取舍：如果减小这个参数的值，就意味着会调小新生代的大小，也会导致新生代GC发生得更频繁，同时，还会导致混合收集周期中回收的老年代分区减少，从而增加FULL GC的风险。这个时间设置得越短，应用的吞吐量也会受到影响。

G1导致的Full GC

1.并发标记阶段Full GC

预留的空间太小，将阈值降低，提前触发GC

2.Mixed GC过后Full GC

回收的空间太小，增加期望时间，让g1能回收更多的内存

3.转移失败（标记复制，复制的时候发现没有空间能复制了）

将阈值降低，增加空间回收的频率

4.大对象分配失败

将阈值降低，增加回收的频率去增加内存整理的频率，避免碎片化。堆转储文件？