# AVL（平衡二叉树）

平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1

当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡

#B树

从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。一个键值对太慢，所以为了更好利用磁盘，为了读到更多的键值。

希望有单个节点可以存储多个键值和数据的平衡树，出现B树。

# B+树

**B+树** 是一个多叉树，也是一个为磁盘而设计的一种平衡查找树，

一个索引一个B+树，非叶子节点存储的是key，叶总节点存储的key和value

主键索引叶子节点： key:主键的值，value:整行数据。 

普通列索引叶子节点： key：索引列的值， value:主键的值。

在 InnoDB 中，我们通过**数据页之间通过双向链表连接**以及**叶子节点中数据之间通过单向链表连接的方式**可以找到表中所有的数据。

为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘的操作，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。

B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。填充因子小于50%，这时需要做合并操作

#冒泡排序

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“冒泡”到了数组最后的位置上。
3. 在未排序的依次类推

# 选择排序

在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

# 插入排序

1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾

#希尔排序

用步长来排序，最后是到步长1时插入排序

步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度

#归并排序

归并排序的思想就是先递归分解数组，再合并数组。

# 快速排序

1. 从数列中挑出一个元素作为基准数。
2. 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。
3. 再对左右区间递归执行第二步，直至各区间只有一个数。

# 堆排序



