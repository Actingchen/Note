# 回溯算法框架

```java
backtrack（输入值 ，路径，...）{
	终止条件；
	for（）{
		剪枝（减去不符合的）
		添加值
		递归
		删除值（撤销操作）
	}
}
```

## 全排列

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

> 输入: [1,2,3]
> 输出:
> [
>   [1,2,3],
>   [1,3,2],
>   [2,1,3],
>   [2,3,1],
>   [3,1,2],
>   [3,2,1]
> ]

```java
class Solution {

    List<List<Integer>> res=new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        if(nums.length==0)
            return res;
        LinkedList<Integer> pum=new LinkedList<>();
        backtrack(nums,pum);
        return res;
    }
    public void backtrack(int[] num,LinkedList<Integer> pum){
        if(pum.size()==num.length){
            res.add(new LinkedList<>(pum));
            return;
        }
        for(int i=0;i<num.length;i++){
            if(pum.contains(num[i])){
                continue;//重复则停止
            }
            pum.add(num[i]);
            backtrack(num,pum);
            pum.removeLast();
        }
    }
}
```

##全排列II

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

> 示例 1：
>
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]
> 示例 2：
>
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```java
class Solution {
    boolean [] vus;
    List<List<Integer>> res =new ArrayList<List<Integer>>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        List<Integer> list=new ArrayList<Integer>();
        vus=new boolean[nums.length];
        Arrays.sort(nums);//保证重复元素相邻
        backtrack(nums,0,list);
        return res;
    }
    public void backtrack(int[] nums,int len,List<Integer> list){
        if(len==nums.length){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(vus[i]||(i>0&&nums[i]==nums[i-1]&&!vus[i-1]))continue;//当前拿过了，为了不重复拿直接停止 或者当元素和上一个元素相同且上一个元素没拿过 直接停止
            //保证每次填入的数一定是这个数所在重复数集合中【从左往右第一个未被填过的数字】
            list.add(nums[i]);
            vus[i]=true;
            backtrack(nums,len+1,list);
            vus[i]=false;
            list.remove(len);
        }
    }
}

```

##[组合总和](https://leetcode-cn.com/problems/combination-sum/)

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1：

输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]

```java
class Solution {

    List<List<Integer>> res=new ArrayList<List<Integer>>();
    List<Integer> list =new ArrayList<Integer>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtrack(candidates,0,target);
        return res;

    }
    public void backtrack(int[] candidates,int start,int target){
        if(target==0){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        
        for(int i=start;i<candidates.length;i++){
            if(target<candidates[i])break;
            list.add(candidates[i]);
            backtrack(candidates,i,target-candidates[i]);
            list.remove(list.size()-1);
        }
    }
}
```

##[组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

```java
class Solution {

    private List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<Integer> path = new ArrayList<>();
        backtrack(path,candidates,target,0,0);
        return res;
    }

    private void backtrack(List<Integer> path,int[] candidates,int target,int sum,int begin) {
        if(sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = begin;i < candidates.length;i++) {
            if(i > begin && candidates[i] == candidates[i-1]) continue;
            int rs = candidates[i] + sum;
            if(rs <= target) {
                path.add(candidates[i]);
                backtrack(path,candidates,target,rs,i+1);
                path.remove(path.size()-1);
            } else {
                break;
            }
        }
    }

}
```

## [组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)



```java
class Solution {
    List<List<Integer>> res=new LinkedList<>();
    int k;
    public List<List<Integer>> combinationSum3(int k, int n) {
        LinkedList<Integer> list=new LinkedList<>();
        this.k=k;
        backtrack(list,1,n);
        return res;
    }

    public void backtrack(LinkedList<Integer> list,int start,int n){
        if (list.size() == k || n <= 0) {
            if(k==list.size()&& n==0){
                res.add(new LinkedList<Integer>(list));   
            }
            return;
        }
        for(int i=start;i<=9;i++){
            if (n - i < 0) return;
            list.add(i);
            backtrack(list,i+1,n-i);
            list.removeLast();
        }
    }
}
```



##[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/

爬楼梯问题 

```
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for(int i = 1; i <= target; i++){
            for(int j = 0; j < nums.length; j++){
                if(i >= nums[j]){
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
```

总结经验：排列是有顺序的，组和是无顺序的。实现的细节：在for循环中排列是i=0，组和是i=start。



#TopK问题

##[最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/)

设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。

```java
//快速选择
//时间复杂度：O(n)
class Solution {
        public int[] smallestK(int[] arr, int k) {
        if(arr.length<=k){
            return arr;
        }
        int lo=0;
        int hi=arr.length-1;
        while(lo<hi){
            int pos=partition(arr,lo,hi);
            if(pos==k-1){
                break;
            }
            else if(pos<k-1){
                lo=pos+1;
            }
            else if(pos>k-1){
                hi=pos-1;
            }
        }
        int[]res=new int [k];
        System.arraycopy(arr,0,res,0,k);
        return res;

    }
    private int partition(int[] arr,int lo,int hi){
        int point=arr[lo];
        while(lo<hi){
            while(lo<hi&&arr[hi]>=point){
                hi--;
            }
            arr[lo]=arr[hi];
            while(lo<hi&&arr[lo]<=point){
                lo++;
            }
            arr[hi]=arr[lo];
        }
        arr[lo]=point;
        return lo;
    }
}


```

```
//构建小顶堆。
//时间复杂度： O(n + kLogn)， 其中
//建初始堆: O(n)
//取top: O(kLogn)

//借助PriorityQueue构建K个堆的方式此处不讨论，该种下时间复杂度为 O(k + nLogk)


    public int[] smallestK(int[] arr, int k) {
        int len = arr.length;
        if (k >= len) {
            return arr;
        }

        buildMinHeap(arr, len);

        int pos = len - k;
        for (int i = len - 1; i >= pos; i--) {
            swap(arr, 0, i);
            heapify(arr, 0, --len);
        }

        int[] ret = new int[k];
        System.arraycopy(arr, pos, ret, 0, k);
        return ret;
    }

    private void buildMinHeap(int[] arr, int len) {
        for (int i = (len - 1) / 2; i >= 0; i--) {
            heapify(arr, i, len);
        }
    }

    private void heapify(int[] arr, int i, int len) {
        if (i >= len) return;

        int min = i;
        int c1 = 2 * i + 1;
        int c2 = 2 * i + 2;

        if (c1 < len && arr[c1] < arr[min]) {
            min = c1;
        }
        if (c2 < len && arr[c2] < arr[min]) {
            min = c2;
        }

        if (min != i) {
            swap(arr, i, min);
            heapify(arr, min, len);
        }
    }

    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```



## [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```java
//快速选择
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int lo=0;
        int hi=nums.length-1;
        while(lo<hi){
            int pos=partition(nums,lo,hi);
            if(pos==k-1){
                break;
            }
            else if(pos<k-1){
                lo=pos+1;
            }
            else if(pos>k-1){
                hi=pos-1;
            }
        }
        return nums[k-1];
    }

    private int partition(int[] arr,int lo,int hi){
        int point=arr[lo];
        while(lo<hi){
            while(lo<hi&&arr[hi]<=point){//右指针开始左遍历
                hi--;
            }
            arr[lo]=arr[hi];
            while(lo<hi&&arr[lo]>=point){
                lo++;
            }
            arr[hi]=arr[lo];
        }
        arr[lo]=point;
        return lo;
    }
}
```





## [字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

示例 :

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。

```java
class Solution {
        public int findKthNumber(int n, int k) {
        int curr = 1;
        k = k - 1;
        while (k > 0) {
            //计算前缀之间的step数
            int steps = getSteps(n, curr, curr + 1);
            //前缀子节点总数大于k，k在里面
            if (steps > k) {
                curr *= 10;//*10进入子节点
                k -= 1;//多了一个确定节点，继续-1
            }
            //前缀子节点总数小于等于k，需要扩大前缀范围，去下一个前缀
            else {//steps==1<k
                curr += 1;
                k -= steps;
            }
        }
        return curr;//当k==0
    }

    private int getSteps(int n, long curr, long next) {//整数n 当前前缀 下一个前缀
        
        int steps = 0;
        while (curr <= n) {
            steps += Math.min(n + 1, next) - curr;//当curr=10  return steps=1
            curr *= 10;
            next *= 10;
        }
        return steps;//确定指定前缀下所有子节点数
    }
}
```

# 动态规划问题

> 什么是动态规划？必须具备3个特点
>
> 最优子结构（子问题相互独立且最优子策略）和无后效性（后面的无法影响前面的）
>
> 还有，子问题的重叠性（空间换时间）
>
> 建立动态规划的步骤
>
> 1.建立dp
>
> 2.dp初始值
>
> 3.选择/状态转移方程
>
> 4.最优解

## [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp=new int[n+1];//n+1是因为可能由最顶阶梯或次顶阶梯跳上楼顶
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];//当前阶梯种数==由它前面 第i-1的跳达种数 + 第i-2阶梯的跳达种数
        }
        return dp[n];
    }
}
```

##[使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。**在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。**

 

示例 1：

输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
 示例 2：

输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n=cost.length;
        int[] dp=new int[n+1];
        dp[0]=dp[1]=0;//题意
        for(int i=2;i<=n;i++){
            dp[i]=Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);//当前阶梯要么是第i-1阶梯要么是第i-2的阶梯跳过来
        }
        return dp[n];
    }
}
```



##[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int row=grid.length;
        int col=grid[0].length;
        int[][]dp=new int [row][col];
        for(int i=row-1;i>=0;i--){
            for(int j=col-1;j>=0;j--){
                if(i==row-1&&j!=col-1){
                    dp[i][j]=grid[i][j]+dp[i][j+1];
                }
                else if(j==col-1&&i!=row-1){
                    dp[i][j]=grid[i][j]+dp[i+1][j];
                }
                else if(i!=row-1&&j!=col-1){
                    dp[i][j]=grid[i][j]+Math.min(dp[i+1][j],dp[i][j+1]);
                }
                else {
                    dp[i][j]=grid[i][j];
                }
            }
        }
        return dp[0][0];

    }
}
```

##[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**思路：**

尝试把当前值加入之前的连续子数组，如果之前的连续子数组小于等于0，就没必要从他们开始了，直接从当前开始计算。

**代码：**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        if(n==0)return 0;
        int maxSum=nums[0];
        for(int i=1;i<n;i++){
            if(nums[i-1]>0)nums[i]+=nums[i-1];
            maxSum=Math.max(nums[i],maxSum);
        }
        return maxSum;
    }
}
```

## [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

**思路：**

和最大子序和类似，都是选择算上当前还是从当前开始

* 当 nums[i] > 0 时，由于是乘积关系：
  最大值乘以正数依然是最大值；
  最小值乘以同一个正数依然是最小值；
* 当 nums[i] < 0 时，依然是由于乘积关系：
  最大值乘以负数变成了最小值；
  最小值乘以同一个负数变成最大值；
* 当 nums[i] = 0 的时候，由于 nums[i] 必须被选取，最大值和最小值都变成 00 ，合并到上面任意一种情况均成立。

**代码：**

```java
public class Solution {

    public int maxProduct(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }

        // dp[i][0]：以 nums[i] 结尾的连续子数组的最小值
        // dp[i][1]：以 nums[i] 结尾的连续子数组的最大值
        int[][] dp = new int[len][2];
        dp[0][0] = nums[0];
        dp[0][1] = nums[0];
        for (int i = 1; i < len; i++) {
            if (nums[i] >= 0) {
                dp[i][0] = Math.min(nums[i], nums[i] * dp[i - 1][0]);
                dp[i][1] = Math.max(nums[i], nums[i] * dp[i - 1][1]);
            } else {
                dp[i][0] = Math.min(nums[i], nums[i] * dp[i - 1][1]);
                dp[i][1] = Math.max(nums[i], nums[i] * dp[i - 1][0]);
            }
        }

        // 只关心最大值，需要遍历
        int res = dp[0][1];
        for (int i = 1; i < len; i++) {
            res = Math.max(res, dp[i][1]);
        }
        return res;
    }
}
```



#链表问题

## [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

null<-1 2->3->4

1<-2 3->4

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null)return head;
        ListNode tail = head, curr = null;
        while(tail != null) {
            ListNode next = tail.next;
            tail.next = curr;
            curr = tail;
            tail=next;
        }
        return curr;
    }
}
```

## 

##[旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
示例 2:

输入: 0->1->2->NULL, k = 4
输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null||head.next==null){
            return head;
        }
        //首尾相连
        int len=1;
        ListNode tail=new ListNode();
        tail=head;
        while(tail.next!=null){
            tail=tail.next;
            len++;
        }
        tail.next=head;
        //找到需要断开的点
        k=k%len;//如果k比len小就k，如果k比len大先让k=k-n*len
        for(int i=0;i<len-k;i++){
            tail=tail.next;
        }
        //找到新的头节点，断开环形
        head=tail.next;
        tail.next=null;
        return head;
    }
}

```

##[剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

```java
class Solution {
    public ListNode deleteNode(ListNode cur, int val) {
        //如果节点为空 则返回空
        if (cur == null) return null;

        //说明当前节点是要删除的节点，则返回当前节点的后继节点（即删除当前节点）
        if (cur.val == val) {
            return cur.next;
        }

        //说明当前节点不是要删除的节点
        //那就继续递归“删除”后继节点
        cur.next = deleteNode(cur.next,val);
        return cur;//成功找到
    }
}
```

## [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)


输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

思路：

不需要知道链表长度，指针1先走k步，然后指针2和指针1同时前进，当指针1指向链表最后一个元素时，指针2即为所求。通过保持指针1和指针2 的距离保证是倒数第k个

```java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode p = head, q = head;
    	int num = 1;
    	while(num < k){
    		q = q.next;
            num++;
    	}
    	while(q.next != null){
    		p = p.next;
    		q = q.next;
    	}
        return p;
    }
}
```

## [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)


输入两个链表，找出它们的第一个公共节点。

如下面的两个链表**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A=headA;
        ListNode B=headB;
        while(A!=B){
            A=(A!=null)?A.next:headB;
            B=(B!=null)?B.next:headA;
        }
        return A;
    }
}
```

##[146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。


进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

示例：

输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4