# 面经

## 什么是反射

（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。**本质是JVM得到class对象之后，再通过class对象进行反编译**，从而获取对象的各种信息。

（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。

```
Class.forName("com.mysql.jdbc.Driver"); //例子
```

## [正向代理和反向代理](https://www.jianshu.com/p/a1c35f5d27f7)

> 简述：
>
> 正向代理 需要在客户端做一些配置（客户端需要配置代理服务器的ip）， 通过代理服务器转发请求给资源服务器，获取资源后转给客户端，正向代理代理的是客户端。（正向代理和客户端同属一个阵营）
>
> * 采用代理服务器可以做一些验证，比如上网权限，因为要连接互联网首先得经过代理服务器。（权限验证）
>
> * “缓存”---可以在代理服务器z做缓存，用户a不用直接访问服务器b就可以拿到所要的数据。（cache）
>
>   由于用户A到服务器B可能需要经过很多路由，导致速度较慢，采用代理，可以“加速访问”
>
>   由图可以看出用户A不能直接访问服务器B，需要代理服务器z，常见实例为“翻墙”
>
> 反向代理 客户端是无感知代理的存在，在它眼中看到的代理服务器就是资源服务器，反向代理服务器是为了服务器们代理，**防火墙和反向代理的共同作用保护了原始资源服务器B，但客户端并不知情**（反向代理和目标服务器同属一个阵营）
>
> * 负载均衡，当http请求过多时，反向代理服务器负责分发http请求，确保某台资源服务器（可以是集群）压力不会太大，而导致崩溃
> * **快取**
>
> 一些反向代理可以充当缓存机。通常，如果您在一分钟内发送一千个请求相同资源的请求，请求将一遍又一遍地到达服务器，请求相同资源，从而浪费了资源和宝贵的时间。这是一种低效的处理方式。但是，在反向代理的帮助下，首次请求资源时，它将缓存（保存）该资源。
>
> 后续请求将不会中继到服务器-代理只会从其缓存中提取所需的资源，它们是保存静态文件副本的完美工具。
>
> - **安全**
>
> 如上所述，如果请求使用反向代理，则请求不会直接到达Web服务器。它们有助于保护Web服务器免受已知漏洞的侵害。如果请求带有恶意意图，则代理会拦截该请求并将其阻止。
>
> 同样，非常重要的事实是，尝试直接攻击Web服务器变得更加困难。为了攻击服务器，您可能最终会攻击代理。但是，这并不是万无一失的情况，因为攻击仍可能到达服务器。

正向代理：

![代理](http://www.511yj.com/pagephoto/plcvch/20160703/zhdaili.jpg)



反向代理：

![代理](http://www.511yj.com/pagephoto/plcvch/20160703/fdaili.jpg)



## BIO（同步阻塞）

Blocking io 就是传统的java io编程

server为每一个client起一个线程来进行处理连接请求

定义：客户端在请求数据的过程中，==**保持一个连接**，**不能做其他事情**==。

底层:

* 服务端用的是1、serversocket注册端口；2、服务端通过调用accept方法监听客户端的socket请求；3、从socket中获取字节输入或者输出流进行数据的读写操作

* 客户端:1、通过socket对象请求与服务端的连接；2、从socket中得到字节输入或者字节输出流进行数据的读写操作

“始终保持一个连接”，则说明，对于客户端和服务端而言，都需要一个线程来维护这个连接，如果服务端没有数据给客户端，则客户端需要一直等待，该连接也需要一直维持。

> 问题1：多线程——但是生成太多线程，内存爆掉
>
> 问题2：用线程池——可能干等着造成线程浪费
>
> BIO不适合高并发的场景，会造成生成过多的线程消耗内存

## NIO（同步非阻塞）

> serversocketChannel

定义：客户端在请求数据的过程中，==**不用保持一个连接**，不能做其他事情==。

上面提到BIO，当有很多个客户端同时向服务端请求数据时，其连接所花费的开销就极大。那么NIO就使用了“不用始终保持一个连接”的方式，解决该问题。其过程为：

客户端发送一个请求，并建立一个连接，服务端接收到了。如果服务端没有数据，就告知客户端“没有数据”；如果有数据，则返回数据。客户端接到了服务端回复的“没有数据”就断开连接，过了一段时间后，客户端重新问服务端是否有数据。服务器重复以上步骤。

客户端反复建立连接询问，如果没有数据则断开连接。这个过程称为“轮询”。**NIO用轮询代替了始终保持一个连接。**

非阻塞模式accept方法不会阻塞

nio的非阻塞是由操作系统内部实现的，底层用的时系统内核的accept

轮询，比如1s

如果连接特别多，但是处理资源的很少，会造成空询（无效的遍历）浪费，

挑出事件触发

跳出来，每次遍历收发的连接

selector多路

注册到selector 每次能感知到某事件发生 只循环处理某事件的事件

![image-20210325205751685](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210325205751685.png)

## AIO（异步非阻塞）

定义：客户端在请求数据的过程中，==不用保持一个连接，**可以做其他事情**==。

AIO也不用始终保持一个连接，但是其处理方式和NIO是不同的。并且这个方式让客户端可以做其他事情。

AIO用了一个通知机制，其流程如下：

客户端向服务端请求数据。服务端若有，则返回数据；若无，则告诉客户端“没有数据”。**客户端收到“没有数据”的回复后，就做自己的其他事情。服务端有了数据之后，就主动通知客户端，并把数据返回去。**

如此一来，整个请求流程中，不仅维持连接的消耗没了，而且客户端可以做别的事情了，节约了客户端的时间。

需要提的是，这里解决了连接的消耗，但是也必然引入了**别的消耗**。这里让客户端能先做别的事情，也肯定会带来**新的麻烦**。

别的消耗是指，服务端需要主动通知客户端，关于“通知”的业务逻辑肯定是需要消耗资源的。新的麻烦是指，客户端本来在做别的事情，突然前面的事情又插过来要做了，必然引入了一个多线程的协调工作。

## [epoll事件轮询模型](https://www.jianshu.com/p/ce380b213859)

每个socket对应一个文件描述符

epoll 主要采用对已就绪的 fd 进行轮询操作

1、在调用 epoll_create 之后，内核就已经创建了一个 eventpoll 红黑树结构体，一个 list 双向链表，在内核态准备接受存储需要监控的 fd。

2、在调用 epoll_ctl之后，直接向内核态的 eventpoll 进行 add/mod/del 对应的 fd，对于新添加进来的 fd，重复的 fd 可以通过 eventpoll 红黑树识别出来，而不需要再次从用户态拷贝到内核态这个过程

3、同时 epoll 还维护了一个双向的 list 链表, 在epoll_ctr执行的时候，除了会向eventpoll 红黑树添加修改外，还会在内核中断函数处理程序中注册一个回调函数，告诉内核，当这个 fd 就绪之后，将他放到 链表 里面去。

4、在 epoll_wait 调用的时候，就是观察这个双向 list 是否有数据，有就直接处理即可

> epoll支持 ET 和 LT 两种触发方式
>  ET(边缘触发)：Nginx 就是采用 ET 触发方式，只支持 no-block 方式，当一个 **fd 缓冲区**就绪的时候，只会发送一次事件触发， 而不会管缓冲区的数据是否已经被读取，都不会再发送第二次
>  LT(水平触发)：支持no-block 和 block 两种方式，当一个 fd 缓冲区就绪时，只要缓冲区有数据，就会不停的发送就绪通知

![这里写图片描述](https://img-blog.csdn.net/20180813172146956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnZWdl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## select、poll、epoll模型的区别

select 同步多路IO复用

**缺点**：

​    （1）单进程可以打开fd有限制；

​    （2）对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低；

​    （2）用户空间和内核空间的复制非常消耗资源；

poll 同步多路IO复用

   调用过程和select类似

   时间复杂度:O(n)

   其和select不同的地方：采用**链表**的方式替换原有fd_set数据结构（数组）,而使其**没有连接数的限制**。

epoll同步多路IO复用 

epoll的工作方式

优点：

1、没有 fd 数量限制，取决于系统内存的大小，一般来说 1GB 就可以有 10W个
 2、内核和用户控件使用同一块内存，mmap技术，没有用户态和内核态之间的拷贝，提高效率
 3、无需遍历所有，仅仅只需要遍历已经就绪的 fd 即可

> * 传值的方式：select是全量传递，每次都要传。epoll是增量传递，只需要传变化的部分。关注的通道很多是性能差别较大。
>
> * 遍历次数：select需要遍历两次，调用时内核需要遍历所有通道发现状态变化的通道；返回后应用还需要遍历所有通道。epoll只需要遍历一次，即应用程序遍历通道，内核无需遍历。在网络中断程序中已经记录发生状态变化的通道。

## jdk8新特性

* Lambda简化了匿名内部类，方法引用简化了lambda

>**Lambda 表达式** − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
>
>**方法引用** − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
>
>**闭包就是一个定义在函数内部的函数**，闭包使得变量即使脱离了该函数的作用域范围也依然能被访问到。
>
>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。

lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）

```java
	  // 类型声明
      MathOperation addition = (int a, int b) -> a + b;
        
      // 不用类型声明
      MathOperation subtraction = (a, b) -> a - b;
        
      // 大括号中的返回语句
      MathOperation multiplication = (int a, int b) -> { return a * b; };
        
      // 没有大括号及返回语句
      MathOperation division = (int a, int b) -> a / b;
```

* **默认方法** − 默认方法就是一个在接口里面有了一个实现的方法。

* **Stream API** −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。

Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。

特点：

        1. 不是数据结构，不会保存数据。
    
        2. 不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。（保留意见：毕竟peek方法可以修改流中元素）
    
        3. 惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。
* **Optional 类** − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。

## 为什么双亲委派机制？

​	 双亲委派机制使得类的加载出现层级,父类加载器加载过的类,子类加载器不会重复加载.可以防止类的重复加载.
​	使得类的加载出现优先级,防止核心API被篡改,提供了安全方面的考量.所以越基础的类就会越上层进行加载.

## 说一个设计模式除了单例代理工厂装饰器

java五大原则
栈里面有什么

## 常量池、运行时常量池、字符串常量池

![img](https://www.pianshen.com/images/681/26d333b407ae501b6ba46e7a154bcb01.png)

**1.常量池（Constant Pool）**

- **什么是常量池？**

​    **常量池（class文件常量池）**：.java文件经过编译后生成.class文件，常量池可以理解为class文件的资源仓库。

- **常量池存放什么**？

​    常量池主要存放两大类常量：**字面量**（文本字符串、声明为final的常量值等）和**符号引用（**有三类：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）

​    总结：常量池（类常量池）就是类在编译后的class文件中的一部分

**2.运行时常量池**

- **什么是运行时常量池？**

  运行时常量池是**方法区的一部分**，如上图所示。**class文件中的常量池在类加载后进入方法区的运行时常量池存放**。

  运行时常量池相对于class温江常量池的一个重要特征是具有**动态性。这是什么意思呢，就是当你的class文件一旦编译后，你的class常量池就是确定了的，而运行时常量池在运行期间也可能有新的常量放入池中（如String类的intern（）方法）**

**3.String常量池（String Pool）**

- 什么是String常量池

  String Pool是java堆内存中的存储字符串的一块区域，如上图所示。

## 为什么搞符号引用再转换成直接引用

​	因为在还没有分配内存的时候用符号引用来代替

## 无限递归

​	虚拟机栈OOM

## 逃逸分析

逃逸分析是jvm在jit即时编译期运行的，是一种确定指针动态范围的方法——分析在程序的哪些地方可以访问到指针。

（如果发现逃逸）**一、对象被赋值给堆中对象的字段和类的静态变量。二、对象被传进了不确定的代码中去运行。**

（如果发现不逃逸）基于逃逸分析的优化：

* 将堆分配转化为栈分配。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。
* 同步消除。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
* 分离对象或标量替换。如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

## mybatis一级缓存二级缓存

一级缓存：

* 一级缓存 Mybatis的一级缓存是指SQLSession，一级缓存的作用域是SQlSession, Mabits默认开启一级缓存。 在同一个SqlSession中，执行相同的SQL查询时；第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。 当执行SQL时候两次查询中间==**发生了增删改的操作，则SQLSession的缓存会被清空。**== 每次查询会先去缓存中找，如果找不到，再去数据库查询，然后把结果写到缓存中。 Mybatis的内部缓存使用一个HashMap，key为hashcode+statementId+sql语句。Value为查询出来的结果集映射成的java对象。 SqlSession执行insert、update、delete等操作commit后会清空该SQLSession缓存。

* 二级缓存

  * 二级缓存是mapper级别的，Mybatis默认是没有开启二级缓存的。 第一次调用mapper下的SQL去查询用户的信息，查询到的信息会存放代该mapper对应的二级缓存区域。 第二次调用namespace下的mapper映射文件中，相同的sql去查询用户信息，会去对应的二级缓存内取结果。即二级缓存被多个SqlSession共享，是一个全局的变量。

    当开启二级缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。

  * 如果sql写在代码里面，还想使用缓存 使用@CacheNamespaceRef注解声明

  * flushCache--用于刷新缓存，默认false，如果true，任何sql每次都会导致一级二级缓存清空。作用：如果同一个mapper里面都有同样的操作，可能有脏读问题，让它清空。也可以设置定时刷新缓存（设置时间，和刷新策略，引用数目记住查询缓存的数目）。

![img](https://img-blog.csdn.net/20150726164148424?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## mybatis-plus特性

* 支持快速生成mapper、model、service、controller层代码，**Mybatis Plus Generator**比**Mybatis Generator**
* 内置分页插件

## mybatis的分页原理

Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。

分页插件的原理就是使用MyBatis提供的插件接口，实现自定义插件，在插件的拦截方法内，拦截待执行的SQL，然后根据设置的dialect（方言），和设置的分页参数，重写SQL ，生成带有分页语句的SQL，执行重写后的SQL，从而实现分页。

举例：`select * from student`，拦截sql后重写为：`select t.* from （select * from student）t limit 0，10`

## java五大基本原则

java面向对象的五大基本原则：

1.单一职责原则：一个类，最好只做一件事，只有一个引起它变化。比如userDao只能对user表crud

2.接口隔离原则：客户端不应该依赖它不需要的接口，使用多个小的专门接口，而不是使用一个大的接口。

3.依赖倒置原则：依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合，有一个缓冲层。

4.里氏替换原则：子类必须能够替换其基类。（继承会带来耦合，尽量提取出来基类再去继承，使得尽量不需要重写，推荐依赖、聚合、组和来解决问题）

5.开闭原则：对扩展开发（作为提供方，允许继承），对修改封闭（作为使用方对修改封闭，只有自己可以修改自己）。eg：抽象类

> 6.迪米特原则：一个类对自己依赖的类知道的越少越好。依赖的类作为成员变量、方法参数、返回类型可以，但是依赖的类作为局部变量不可以。
>
> 7.组和复用原则：尽量使用组和和聚合，而不是集成来达到复用的目的。

## 六种关系

###依赖、泛化[继承]、实现

依赖：用到哪个类，就有了依赖关系

泛化[继承]：继承关系。依赖关系的特例。

实现：实现接口

### 关联、聚合、组和

关联：类B单纯作为类A的成员变量

聚合：类B不仅仅是作为类A的成员变量，里面有setB(B b)

组和：类B不仅仅是类A的成员变量，还在类A里创建，同生命周期

![image-20210327225535537](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210327225535537.png)

## 工厂、单例、代理、观察者模式、适配器、装饰器模式

### 模板方法模式

模板方法模式，又叫模板模式，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义 的方法执行

简单地说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤

```
make（）{
	fun1（）
	抽象方法fun2（）
	fun3（）
}
```

豆浆制作

豆浆抽象类 = new 子类红豆豆浆（）

豆浆抽象类=new 子类花生豆浆（）

纯豆浆

定义一个钩子方法，默认空实现，如果实现了，就按照子类去实现

钩子方法（是否添加配料）

```
make（）{
	fun1（）
		if（钩子方法）{
		抽象方法fun2（）
	}
	fun3（）
}
钩子方法（） 
```

> 例如
>
> ![image-20210328154749786](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210328154749786.png)

## [装饰者模式](https://www.bilibili.com/video/BV1G4411c7N4?p=74)

动态地把新功能添加上

问题：解决星巴克经常添加新品

装饰者模式：打包一个快递

被装饰者与装饰者的关系是继承+组和的关系（装饰类继承于被装饰类，且被装饰类是他的组和

装饰类里面含有一个被装饰的对象

![image-20210328181104117](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210328181104117.png)



新添加单品只需要去继承就可以了。

·![image-20210328191705665](C:\Users\11468\AppData\Roaming\Typora\typora-user-images\image-20210328191705665.png)

java的io结构，filterInputStream就是一个装饰者

## springboot的优势

优点
Spring Boot自己根本无法完成SSM能完成的工作，需要其他starter作为桥梁，自动帮你配置好对应的框架才行。
springboot采用约定大于配置的方式
类似定制房屋 Spring Boot没有必须用Spring MVC，可以不用，也可以换成Spring WebFlux。
它可以快速开发
可以独立运行 可以内嵌tomcat等容器
springboot倡导前后端分离开发，提倡springBoot的应用只向前端提供restfulAPI，如果不分离需要额外的配置

## [Springboot如何实现自动配置](https://juejin.cn/post/6943466202119274503#heading-0)

`SpringBoot` 这些特点中最重要的两条就是**约定优于配置**和**自动装配**。

## 约定优于配置

`SpringBoot` 的约定由于配置主要体现在以下方面：

- `maven` 项目的配置文件存放在 `resources` 资源目录下。
- `maven` 项目默认编译后的文件放于 `target` 目录。
- `maven` 项目默认打包成 `jar` 格式。
- 配置文件默认为 `application.yml` 或者 `application.yaml` 或者 `application.properties`。
- 默认通过配置文件 `spring.profiles.active` 来激活配置。

## 自动装配

搭建一个 `SpringBoot` 应用，我们只需要引入一个注解 `@SpringBootApplication`，就可以成功运行。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a2fb9d16d8643238b3f1f26ddca1f09~tplv-k3u1fbpfcp-watermark.image)

前面四个不用说，是定义一个注解所必须的，关键就在于后面三个注解：`@SpringBootConfiguration`，`@EnableAutoConfiguration`，`@ComponentScan`。也就是说我们如果不用 `@SpringBootApplication` 这个复合注解，而是直接使用最下面这三个注解，也能启动一个 `SpringBoot` 应用。

### @SpringBootConfiguration 注解

它实际上就是一个 `@Configuration` 注解，加上这个注解就是为了让当前类作为一个配置类交由 `Spring` 的 `IOC` 容器进行管理

### @ComponentScan 注解

用于定义 `Spring` 的扫描路径，等价于在 `xml` 文件中配置 `<context:component-scan>`，假如不配置扫描路径，那么 `Spring` 就会默认扫描当前类所在的包及其子包中的所有标注了 `@Component`，`@Service`，`@Controller` 等注解的类。

### @EnableAutoConfiguration

> 关键：它是一个由 `@AutoConfigurationPackage` 和 `@Import` 注解组成的复合注解。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d20df65903f41419cd103bbfdd520b9~tplv-k3u1fbpfcp-watermark.image)

这里的 `@Import` 注解其实就是为了去导入一个类 `AutoConfigurationImportSelector`，接下来我们需要分析一下这个类。

##### AutoConfigurationImportSelector 类

这个方法很好理解，首先就是看一下 `AnnotationMetadata`（注解的元信息），有没有数据，没有就说明没导入直接返回一个空数组，否则就调用

进入 `getAutoConfigurationEntry` 方法：这个方法里面就是通过调用 `getCandidateConfigurations` 来获取候选的 `Bean`，并将其存为一个集合，最后经过去重，校验等一系列操作之后，被封装成 `AutoConfigurationEntry` 对象返回。

继续进入 `getCandidateConfigurations` 方法，这时候就几乎看到曙光了：

这里面再继续点击去就没必要了，看错误提示大概就知道了，`loadFactoryNames` 方法会去 `META-INF/spring.factories` 文件中根据 `EnableAutoConfiguration` 的全限定类名获取到我们需要导入的类，而 `EnableAutoConfiguration` 类的全限定类名为 `org.springframework.boot.autoconfigure.EnableAutoConfiguration`，那么就让我们打开这个文件看一下：

可以看到，这个文件中配置了大量的需要自动装配的类，当我们启动 `SpringBoot` 项目的时候，`SpringBoot` 会扫描所有 `jar` 包下面的 `META-INF/spring.factories` 文件，并根据 `key` 值进行读取，最后在经过去重等一些列操作得到了需要自动装配的类。

需要注意的是：上图中的 `spring.factories` 文件是在 `spring-boot-autoconfigure` 包下面，这个包记录了官方提供的 `stater` 中几乎所有需要的自动装配类，所以并不是每一个官方的 `starter` 下都会有 `spring.factories` 文件。

#### @AutoConfigurationPackage 注解

从这个注解继续点进去之后可以发现，它最终还是一个 `@Import` 注解：

这个时候它导入了一个 `AutoConfigurationPackages` 的内部类 `Registrar`， 而这个类其实作用就是读取到我们在最外层的 `@SpringBootApplication` 注解中配置的扫描路径（没有配置则默认当前包下），然后把扫描路径下面的类都加到数组中返回。

## Linux什么命令精准查找文件

find <指定目录><指定条件><指定动作>，即find pathname -options [-print -exec -ok]

--复习--

redis包含的模块

redis五大基本类型
跳表
redis的多路复用
主从复制
RDB AOF
动态规划、字符串、链表