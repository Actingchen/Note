#Redis

##基础入门

* 数据结构
  * 字符串——strings
  * 哈希——hashes
  * 列表——lists (lpush rpop lindex lrange )
  * 集合——sets
* 特点
  * Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人
  * 同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性
* 场景
  * 缓存、排行榜、计数器、社交网络、消息队列(但不是专门的）等
* 缺点？
  * 快照因为是把数据存进硬盘，它比较耗时，所以做存储的时候会阻塞，快照不适合实时立即去做，定时任务去做。
  * 日志是追加去做，不适合恢复数据

> Spring整合redis

* 引入依赖

  ```
  <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-data-redis</artifactId>
              <version>2.1.5.RELEASE</version>
  </dependency>
  ```

* 配置Redis

  * .properties文件中配置数据库参数

  ```yml
  #Redis
  spring.redis.database=11
  spring.redis.host=localhost
  spring.redis.port=6379
  spring.redis.password=xxxxx
  ```

  * 编写配置类，构造RedisTemplate

* 访问Redis

  * redisTemplate.opsForValue()
  * redisTemplate.opsForHash()
  * redisTemplate.opsForList()
  * redisTemplate.opsForSet()
  * redisTemplate.opsForZSet()

## 介绍一下redis

Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构。

**Redis 的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。

另外，**Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。**

**Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。**

##为什么需要redis？

1、传统数据库的每秒执行事务数有限制，很容易出现慢查询

2、**我们为了避免用户在请求数据的时候获取速度过于缓慢，所以我们在数据库之上增加了缓存这一层来弥补**

类似 **CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。** **再比如操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache）。**

![image-20201121201529996](\images\image-20201121201529996.png)



## redis的数据结构

底层数据结构一共有6种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表、整数数组

![](\images\1126.jpg)

> 键和值用什么结构组织？

哈希表

##redis如何解决哈希冲突和rehash带来的阻塞操作？

* Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。
* 为了减少单个桶的链表过长



**渐进式 rehash 期间的哈希表操作**

load_factor = ht[0].used / ht[0].size   负载因子 = 哈希表已保存节点数量 / 哈希表数组大小

**~扩容**

- 当服务器没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于1
- 服务器正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于5

**~缩容**

* 当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

**~rehash**

为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

​    给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；

​    把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；

​    释放哈希表 1 的空间。

到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。这个过程看似简单，但是第二步涉及大量的数据拷贝，

如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：渐进式rehash这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。新添加到字典上的键值对只会保存在哈希表2上，而哈希表1上不再进行任何添加操作，这样就保证了哈希表1中包含的键值对的数量只减不增，并随着rehash的进行而逐渐变成空表。 

## Redis是单线程吗？

Redis是单线程，主要是是指Redis的网络IO和键值对读写是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程。但Redis的其它功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。



##为什么单线程Redis能这么快？

一方面，Redis的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的重要原因

另一方面，就是Redis采用了多路复用机制，使其在网络IO操作种能并发处理大量的客户端请求，实现高吞吐率。

**多路复用机制**

类似基于多路复用的高性能 I/O 模型Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

##AOF日志：宕机了，Redis如何避免数据丢失？

由于Redis常常用于当作缓存，所以衍生出一个问题：一旦redis服务器宕机，内存中的数据将全部丢失。

如果从数据库中恢复，频繁访问会给数据库很大的压力，而且这些数据从传统数据库会慢查询，响应速度比不上Redis。

AOF日志：“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。可以避免出现记录错误命令的情况。除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作。

**三种写回策略**

但是写回虽然避免了对当前命令的阻塞，但是给下一个操作带来了阻塞风险，AOF是主线程执行，如果日志文件写入ipan每次盘写压力大，就会导致写很慢，进而导致后面的操作无法执行，此时宕机。可能丢失。

AOF 配置项 appendfsync 的三个可选值。

* Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
* Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
* No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

![](\images\72f547f18dbac788c7d11yy167d7ebf8.jpg)

总结一下就是：想要获得高性能，就选择 No 策略；如果想要得到高可靠性保证，就选择 Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。

**日志文件太大？**

实际上，重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令

**重写会阻塞主线程吗？**

总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。

## RDB快照：redis宕机后如何快速恢复？

RDB快照：内存快照。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

* save：在主线程中执行，会导致阻塞；
* bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销！！！！

Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

## redis和数据库数据一致性问题

\# **解决这三大矛盾的刷新策略包括**

1. 实时策略
2. ——用户体验好，是默认应该使用的策略；
3. 异步策略
4. ——适用于并发量大，但是数据没有那么关键的情况，好处是实时性好；
5. 定时策略
6. ——并发量实在太大，数据量也大的情况，异步都难以满足的场景；

实时策略是最常用的策略，也是保持实时性最好的策略：

- 读取的过程，应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。如果命中，应用程序从 cache 中取数据，取到后返回。
- 写入的过程，把数据存到数据库中，成功后，再让缓存失效，失效后下次读取的时候，会被写入缓存。

从用户体验的角度，应该数据库有了写入，就马上废弃缓存，触发一次数据库的读取，从而更新缓存。

然而，这和第三个问题（高并发）就矛盾了——如果所有的都实时从数据库里面读取，高并发场景下，数据库往往受不了。

[谈谈数据库，缓存一致性 (juejin.cn)](https://juejin.cn/post/6844904034252357645)













































---

分布式中的cap理论

一致性（`Consistency`）：数据在多个副本之间是否能够保持一致的特性。（当一个系统在一致状态下更新后，应保持系统中所有数据仍处于一致的状态）

**可用性**（`Availability`）：系统提供的服务必须一直处于可用状态，对每一个操作的请求必须在有限时间内返回结果。

**分区容错性**（`Tolerance of network Partition`）：分布式系统在遇到网络分区故障时，仍然需要保证对外提供一致性和可用性的服务，除非整个网络都发生故障。

> 最多只能同时满足两个,redis 满足cp

![image-20201125105632480](\images\image-20201125105632480.png)



????

缓存与数据库数据库不同步怎么办？加一个中间件。或者采取一个定时同步。

想加节点怎么办？一致性哈希要怎么做？

redis挂了怎么办？数据库穿透怎么办？



