#Redis

##基础入门

* 数据结构
  * 字符串——strings
  * 哈希——hashes
  * 列表——lists (lpush rpop lindex lrange )
  * 集合——sets
* 特点
  * Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人
  * 同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性
* 场景
  * 缓存、排行榜、计数器、社交网络、消息队列(但不是专门的）等
* 缺点？
  * 快照因为是把数据存进硬盘，它比较耗时，所以做存储的时候会阻塞，快照不适合实时立即去做，定时任务去做。
  * 日志是追加去做，不适合恢复数据

> Spring整合redis

* 引入依赖

  ```
  <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-data-redis</artifactId>
              <version>2.1.5.RELEASE</version>
  </dependency>
  ```

* 配置Redis

  * .properties文件中配置数据库参数

  ```yml
  #Redis
  spring.redis.database=11
  spring.redis.host=localhost
  spring.redis.port=6379
  spring.redis.password=xxxxx
  ```

  * 编写配置类，构造RedisTemplate

* 访问Redis

  * redisTemplate.opsForValue()
  * redisTemplate.opsForHash()
  * redisTemplate.opsForList()
  * redisTemplate.opsForSet()
  * redisTemplate.opsForZSet()

##为什么需要redis？

1、传统数据库的每秒执行事务数有限制，很容易出现慢查询

2、**我们为了避免用户在请求数据的时候获取速度过于缓慢，所以我们在数据库之上增加了缓存这一层来弥补**

类似 **CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。** **再比如操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache）。**

![image-20201121201529996](images\image-20201121201529996.png)

## 介绍一下redis

Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构。

**Redis 的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。

另外，**Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。**

**Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。**

## redis的数据结构

底层数据结构一共有6种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表、整数数组

![](C:\Users\11468\Desktop\Study\Note\images\1126.jpg)

> 键和值用什么结构组织？

哈希表

* 哈希冲突怎么解决？
  * Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。
  * 为了减少单个桶的链表过长

为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

​    给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；

​    把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；

​    释放哈希表 1 的空间。

到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。这个过程看似简单，但是第二步涉及大量的数据拷贝，

如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：渐进式rehash这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

**渐进式 rehash 期间的哈希表操作**

因为在渐进式 rehash 的过程中，字典会同时使用 ht[0] 和 ht[1] 两个哈希表，所以在这个过程中对字典的增删改查操作会在两个哈希表上进行。例如在字典上查找一个键时，程序会先查询ht[0]，如果没有查到就再查 ht[1]。
 新添加到字典上的键值对只会保存在ht[1]上，而ht[0]上不再进行任何添加操作，这样就保证了ht[0]中包含的键值对的数量只减不增，并随着rehash的进行而逐渐变成空表。

##为什么单线程Redis能这么快？





##分布式中的cap理论

一致性（`Consistency`）：数据在多个副本之间是否能够保持一致的特性。（当一个系统在一致状态下更新后，应保持系统中所有数据仍处于一致的状态）

**可用性**（`Availability`）：系统提供的服务必须一直处于可用状态，对每一个操作的请求必须在有限时间内返回结果。

**分区容错性**（`Tolerance of network Partition`）：分布式系统在遇到网络分区故障时，仍然需要保证对外提供一致性和可用性的服务，除非整个网络都发生故障。

> 最多只能同时满足两个,redis 满足cp

![image-20201125105632480](\images\image-20201125105632480.png)































##


#

缓存与数据库数据库不同步怎么办？加一个中间件。或者采取一个定时同步。

想加节点怎么办？一致性哈希要怎么做？

redis挂了怎么办？数据库穿透怎么办？



